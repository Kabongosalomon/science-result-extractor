section: title
Finding Function in Form: Compositional Character Models for Open Vocabulary Word Representation
section: abstract
We introduce a model for constructing vector representations of words by composing characters using bidirectional LSTMs. Relative to traditional word representation models that have independent vectors for each word type, our model requires only a single vector per character type and a fixed set of parameters for the compositional model. Despite the compactness of this model and, more importantly, the arbitrary nature of the form-function relationship in language , our "composed" word representations yield state-of-the-art results in language modeling and part-of-speech tagging. Benefits over traditional baselines are particularly pronounced in morphologically rich languages (e.g., Turkish).
section: Introduction
Good representations of words are important for good generalization in natural language processing applications. Of central importance are vector space models that capture functional (i.e., semantic and syntactic) similarity in terms of geometric locality. However, when word vectors are learned-a practice that is becoming increasingly common-most models assume that each word type has its own vector representation that can vary independently of other model components. This paper argues that this independence assumption is inherently problematic, in particular in morphologically rich languages (e.g., Turkish). In such languages, a more reasonable assumption would be that orthographic (formal) similarity is evidence for functional similarity.
However, it is manifestly clear that similarity inform is neither a necessary nor sufficient condition for similarity in function: small orthographic differences may correspond to large semantic or syntactic differences, and large orthographic differences may obscure nearly perfect functional correspondence (rich vs. affluent). Thus, any orthographically aware model must be able to capture non-compositional effects in addition to more regular effects due to, e.g., morphological processes. To model the complex formfunction relationship, we turn to long short-term memories (LSTMs), which are designed to be able to capture complex non-linear and non-local dynamics in sequences (Hochreiter and). We use bidirectional LSTMs to "read" the character sequences that constitute each word and combine them into a vector representation of the word. This model assumes that each character type is associated with a vector, and the LSTM parameters encode both idiosyncratic lexical and regular morphological knowledge.
To evaluate our model, we use a vectorbased model for part-of-speech (POS) tagging and for language modeling, and we report experiments on these tasks in several languages comparing to baselines that use more traditional, orthographically-unaware parameterizations. These experiments show: (i) our characterbased model is able to generate similar representations for words that are semantically and syntactically similar, even for words are orthographically distant (e.g., October and January); our model achieves improvements over word lookup tables using only a fraction of the number of parameters in two tasks; (iii) our model obtains state-of-theart performance on POS tagging (including establishing anew best performance in English); and (iv) performance improvements are especially dramatic in morphologically rich languages.
The paper is organized as follows: Section 2 presents our character-based model to generate word embeddings. Experiments on Language Modeling and POS tagging are described in Sections 4 and 5. We present related work in Section 6; and we conclude in Section 7.
section: Word Vectors and Wordless Word Vectors
It is commonplace to represent words as vectors.
In contrast to na¨ıvena¨ıve models in which all word types in a vocabulary V are equally different from each other, vector space models capture the intuition that words maybe different or similar along a variety of dimensions. Learning vector representations of words by treating them as optimizable parameters in various kinds of language models has been found to be a remarkably effective means for generating vector representations that perform well in other tasks). Formally, such models define a matrix P ∈ R d×|V | , which contains d parameters for each word in the vocabulary V . For a given word type w ∈ V , a column is selected by right-multiplying P by a one-hot vector of length |V |, which we write 1 w , that is zero in every dimension except for the element corresponding tow. Thus, P is often referred to as word lookup table and we shall denote bye W w ∈ Rd the embedding obtained from a word lookup table for was e W w = P · 1 w . This allows tasks with low amounts of annotated data to be trained jointly with other tasks with large amounts of data and leverage the similarities in these tasks. A common practice to this end is to initialize the word lookup table with the parameters trained on an unsupervised task. Some examples of these include the skip-n-gram and CBOW models of.
section: Problem: Independent Parameters
There are two practical problems with word lookup tables. Firstly, while they can be pretrained with large amounts of data to learn semantic and syntactic similarities between words, each vector is independent. That is, even though models based on word lookup tables are often observed to learn that cats, kings and queens exist in roughly the same linear correspondences to each other as cat, king and queen do, the model does not represent the fact that adding an sat the end of the word is evidence for this transformation. This means that word lookup tables cannot generate representations for previously unseen words, such as Frenchification, even if the components, French and -ification, are observed in other contexts.
Second, even if copious data is available, it is impractical to actually store vectors for all word types. As each word type gets a set of parameters d, the total number of parameters is d×|V |, where |V | is the size of the vocabulary. Even in relatively morphological poor English, the number of word types tends to scale to the order of hundreds of thousands, and in noisier domains, such as online data, the number of word types raises considerably. For instance, in the English wikipedia dump with 60 million sentences, there are approximately 20 million different lowercased and tokenized word types, each of which would need its own vector. Intuitively, it is not sensible to use the same number of parameters for each word type.
Finally, it is important to remark that it is uncontroversial among cognitive scientists that our lexicon is structured into related forms-i.e., their parameters are not independent. The wellknown "past tense debate" between connectionists and proponents of symbolic accounts concerns disagreements about how humans represent knowledge of inflectional processes (e.g., the formation of the English past tense), not whether such knowledge exists).
section: Solution: Compositional Models
Our solution to these problems is to construct a vector representation of a word by composing smaller pieces into a representation of the larger form. This idea has been explored in prior work by composing morphemes into representations of words (. Morphemes are an ideal primitive for such a model since they areby definition-the minimal meaning-bearing (or syntax-bearing) units of language. The drawback to such approaches is they depend on a morphological analyzer.
In contrast, we would like to compose representations of characters into representations of words. However, the relationship between words forms and their meanings is non-trivial (. While some compositional relationships exist, e.g., morphological processes such as adding -ing or -ly to a stem have relatively regular effects, many words with lexical similarities convey different meanings, such as, the word pairs lesson ⇐⇒ lessen and coarse ⇐⇒ course.
section: C2W Model
Our compositional character to word (C2W) model is based on bidirectional LSTMs (Graves and, which are able to learn complex non-local dependencies in sequence models. An illustration is shown in. The input of the C2W model (illustrated on bottom) is a single word type w, and we wish to obtain is a d-dimensional vector used to represent w. This model shares the same input and output of a word lookup table (illustrated on top), allowing it to easily replace then in any network.
As input, we define an alphabet of characters C. For English, this vocabulary would contain an entry for each uppercase and lowercase letter as well as numbers and punctuation. The input word w is decomposed into a sequence of characters c 1 , . . . , cm , where m is the length of w. Each c i is defined as a one hot vector 1 c i , with one on the index of c i in vocabulary M . We define a projection layer PC ∈ Rd C ×|C| , where d C is the number of parameters for each character in the character set C. This of course just a character lookup table, and is used to capture similarities between characters in a language (e.g., vowels vs. consonants). Thus, we write the projection of each input character c i as e c i = PC · 1 c i .
Given the input vectors x 1 , . . . , x m , a LSTM computes the state sequence h 1 , . . . , h m+1 by iteratively applying the following updates:.......
section: Word Lookup Table
Bi-LSTM embeddings for word "cats" embeddings for word "cats" timestamp t. The information that is propagated from c t−1 to ct is controlled by the three gates it , ft , and o t , which determine the what to include from the input x t , the what to forget from c t−1 and what is relevant to the current state ht . We write W to refer to all parameters the LSTM (W ix , W f x , bf , . . . ). Thus, given a sequence of character representations e C c 1 , . . . , e C cm as input, the forward LSTM, yields the state sequence sf 0 , . . . , sf m , while the backward LSTM receives as input the reverse sequence, and yields states s b m , . . . , s b 0 . Both LSTMs use a different set of parameters W f and W b . The representation of the word w is obtained by combining the forward and backward states:
Caching for Efficiency. Relative toe W w , computing e C w is computational expensive, as it requires two LSTMs traversals of length m. However, e C w only depends on the character sequence of that word, which means that unless the parameters are updated, it is possible to cache the value of e C w for each different w's that will be used repeatedly. Thus, the model can keep a list of the most frequently occurring word types in memory and run the compositional model only for rare words. Obviously, caching all words would yield the same performance as using a word lookup table e W w , but also using the same amount of memory. Consequently, the number of word types used in cache can be adjusted to satisfy memory vs. performance requirements of a particular application.
At training time, when parameters are changing, repeated words within the same batch only need to be computed once, and the gradient at the output can be accumulated within the batch so that only one update needs to be done per word type. For this reason, it is preferable to define larger batches.
section: Experiments: Language Modeling
Our proposed model is similar to models used to compute composed representations of sentences from words (. However, the relationship between the meanings of individual words and the composite meaning of a phrase or sentence is arguably more regular than the relationship of representations of characters and the meaning of a word. Is our model capable of learning such an irregular relationship? We now explore this question empirically.
Language modeling is a task with many applications in NLP. An effective LM requires syntactic aspects of language to be modeled, such as word orderings (e.g., "John is smart" vs. "John smart is"), but also semantic aspects (e.g., "John ate fish" vs. "fish ate John"). Thus, if our C2W model only captures regular aspects of words, such as, prefixes and suffixes, the model will yield worse results compared to word lookup tables.
section: Language Model
Language modeling amounts to learning a function that computes the log probability, log p(w), of a sentence w = (w 1 , . . . , w n ). This quantity can be decomposed according to the chain rule into the sum of the conditional log probabilities n i=1 log p(w i | w 1 , . . . , w i−1 ). Our language model computes log p(w i | w 1 , . . . , w i−1 ) by composing representations of words w 1 , . . . , w i−1 using an recurrent LSTM model ().
The model is illustrated in, where we observe on the first level that each word w i is projected into their word representations. This can be done by using word lookup tables e W w i , in which case, we will have a regular recurrent language model. To use our C2W model, we can simply replace the word lookup table with the model f (w i ) = e C w i . Each LSTM block s i , is used to predict word w i+1 . This is performed by projecting the s i into a vector of size of the vocabulary V and performing a softmax.  The softmax is still simply ad × V table, which encodes the likelihood of every word type in a given context, which is a closed-vocabulary model. Thus, attest time out-of-vocabulary (OOV) words cannot be addressed. A strategy that is generally applied is to prune the vocabulary V by replacing word types with lower frequencies as an OOV token. At test time, the probability of words not in vocabulary is estimated as the OOV token. Thus, depending on the number of word types that are pruned, the global perplexities may decrease, since there are fewer outcomes in the softmax, which makes the absolute value of perplexity not informative when comparing models of different vocabulary sizes. Yet, the relative perplexity between different models indicates which models can better predict words based on their contexts.
To address OOV words in the baseline setup, these are replaced by an unknown token, and also associated with a set of embeddings. During training, word types that occur once are replaced with the unknown token stochastically with 0.5 probability. The same process is applied at the character level for the C2W model.
section: Experiments
Datasets We look at the language model performance on English, Portuguese, Catalan, German and Turkish, which have abroad range of morphological typologies. While all these languages contain inflections, in agglutinative languages affixes tend to be unchanged, while in fusional languages they are not. For each language, Wikipedia articles were randomly extracted until 1 million words are obtained and these were used for training. For development and testing, we extracted an additional set of 20,000 words.
Setup We define the size of the word representation d to 50. In the C2W model requires setting the dimensionality of characters d C and current states d CS . We set d C = 50 and d CS = 150. Each LSTM state used in the language model sequence s i is set to 150 for both states and cell memories. Training is performed with mini-batch gradient descent with 100 sentences. The learning rate and momentum were set to 0.2 and 0.95. The softmax over words is always performed on lowercased words. We restrict the output vocabulary to the most frequent 5000 words. Remaining word types will be replaced by an unknown token, which must also be predicted. The word representation layer is still performed overall word types (i.e., completely open vocabulary). When using word lookup tables, the input words are also lowercased, as this setup produces the best results. In the C2W, case information is preserved.
Evaluation is performed by computing the perplexities over the test data, and the parameters that yield the highest perplexity over the development data are used.
Perplexities Perplexities over the testset are reported on. From these results, we can see that in general, it is clear that C2W always outperforms word lookup tables (row "Word"), and that improvements are especially pronounced in Turkish, which is a highly morphological language, where word meanings differ radically depending    in-vocabulary words and two nonce words .This makes our model generalize significantly better than lookup tables that generally use unknown tokens for OOV words. Furthermore, this ability to generalize is much more similar to that of human beings, who are able to infer meanings for new words based on its form.
section: Experiments: Part-of-speech Tagging
As a second illustration of the utility of our model, we turn to POS tagging. As morphology is a strong indicator for syntax in many languages, a much effort has been spent engineering features (). We now show that some of these features can be learnt automatically using our model.
section: Bi-LSTM Tagging Model
Our tagging model is likewise novel, but very straightforward. It builds a Bi-LSTM over words as illustrated in. The input of the model is a sequence of features f (w 1 ), . . . , f (w n ). Once again, word vectors can either be generated using the C2W model f (w i ) = e C w i , or word lookup tables f (w i ) = e W w i . We also test the usage of hand-engineered features, in which case f 1 (w i ), . . . , f n (w i ). Then, the sequential features f (w 1 ), . . . , f (w n ) are fed into a bidirectional LSTM model, obtaining the forward states sf 0 , . . . , sf n and the backward states s b N +1 , . . . , s b 0 . Thus, state sf i contains the information of all words from 0 to i and s bi from n to i. The forward and backward states are combined, for each index from 1 ton, as follows:
where L f , L band bl are parameters defining how the forward and backward states are combined.
1 software submitted as supplementary material
The size of the forward sf and backward states s band the combined state l are hyperparameters of the model, denoted as d f W S , db W Sand d W S , respectively. Finally, the output labels for index i are obtained as a softmax over the POS tagset, by projecting the combined state l i .
section: Experiments
Datasets For English, we conduct experiments on the Wall Street Journal of the Penn Treebank dataset (, using the standard splits (sections 1-18 for train, 19-21 for tuning and 22-24 for testing). We also perform tests on 4 other languages, which we obtained from the CoNLL shared tasks. While the PTB dataset provides standard train, tuning and test splits, there are no tuning sets in the datasets in other languages, so we withdraw the last 100 sentences from the training dataset and use them for tuning.
Setup The POS model requires two sets of hyperparameters. Firstly, words must be converted into continuous representations and the same hyperparametrization as in language modeling (Section 4) is used. Additionally, we also compare to the convolutional model of, which also requires the dimensionality for characters and the word representation size, which are set to 50 and 150, respectively. Secondly, words representations are combined to en-code context. Our POS tagger has three hyperparameters d f W S , db W Sand d W S , which correspond to the sizes of LSTM states, and are all set to 50. As for the learning algorithm, use the same setup (learning rate, momentum and mini-batch sizes) as used in language modeling.
Once again, we replace OOV words with an unknown token, in the setup that uses word lookup tables, and the same with OOV characters in the C2W model. In setups using pre-trained word embeddings, we consider a word an OOV if it was not seen in the labelled training data as well as in the unlabeled data used for pre-training.
Compositional Model Comparison A comparison of different recurrent neural networks for the C2W model is presented in. We used our proposed tagger tagger in all experiments and results are reported for the English Penn Treebank. Results on label accuracy test set is shown in the column "acc". The number of parameters in the word composition model is shown in the column "parameters". Finally, the number of words processed attest time per second are shown in column "words/sec".
We observe that approaches using RNN yield worse results than their LSTM counterparts with a difference of approximately 2%. This suggests that while regular RNNs can learn shorter character sequence dependencies, they are not ideal to learn longer dependencies. LSTMs, on the other hand, seem to effectively obtain relatively higher results, on par with using word lookup tables (row "Word Lookup"), even when using forward (row "Forward LSTM") and backward (row "Backward LSTM") LSTMs individually. The best results are obtained using the bidirectional LSTM (row "Bi-LSTM"), which achieves an accuracy of 97.29% on the test set, surpassing the word lookup table. The convolution model) obtained slightly lower results (row "Convolutional (S&Z)"), we think this is because the convolutional model uses a max-pooling layer over series of window convolutions. As order is only perserved within windows, longer distance dependences are unobserved.
There are approximately 40k lowercased word types in the training data in the PTB dataset. Thus, a word lookup table with 50 dimensions per type contains approximately 2 million parameters. In the C2W models, the number of characters types (including uppercase and lowercase) is approxi-: POS accuracy results for the English PTB using word representation models.
mately 80. Thus, the character lookup table consists of only 4k parameters, which is negligible compared to the number of parameters in the compositional model, which is once again 150k parameters. One could argue that results in the Bi-LSTM model are higher than those achieved by other models as it contains more parameters, so we set the state size d CS = 50 (row "Bi-LSTM d CS = 50") and obtained similar results.
In terms of computational speed, we can observe that there is a more significant slowdown when applying the C2W models compared to language modeling. This is because there is no longer a softmax over the whole word vocabulary as the main bottleneck of the network. However, we can observe that while the Bi-LSTM system is 3 times slower, it is does not significantly hurt the performance of the system.
Results on Multiple Languages Results on 5 languages are shown in. In general, we can observe that the model using word lookup tables (row "Word") performs consistently worse than the C2W model (row "C2W"). We also compare our results with Stanford's POS tagger, with the default set of features, found in. Results using these tagger are comparable or better than state-of-the-art systems. We can observe that inmost cases we can slightly outperform the scores obtained using their tagger. This is a promising result, considering that we use the same training data and do not handcraft any features. Furthermore, we can observe that for Turkish, our results are significantly higher (>4%).
Comparison with Benchmarks Most state-ofthe-art POS tagging systems are obtained by either learning or handcrafting good lexical features: POS accuracies on different languages ditional raw data to learn features in an unsupervised fashion. Generally, optimal results are obtained by performing both. shows the current Benchmarks in this task for the English PTB. Accuracies on the test set is reported on column "acc". Columns "+feat" and "+data" define whether hand-crafted features are used and whether additional data was used. We can see that even without feature engineering or unsupervised pretraining, our C2W model (row "C2W") is on par with the current state-of-the-art system (row "structReg"). However, if we add hand-crafted features, we can obtain further improvements on this dataset (row "C2W + features").
However, there are many words that do not contain morphological cues to their part-of-speech. For instance, the word snake does not contain any morphological cues that determine its tag. In these cases, if they are not found labelled in the training data, the model would be dependent on context to determine their tags, which could lead to errors in ambiguous contexts. Unsupervised training methods such as the Skip-n-gram model can be used to pretrain the word representations on unannotated corpora. If such pretraining places cat, dog and snake near each other in vector space, and the supervised POS data contains evidence that cat and dog are nouns, our model will be likely to label snake with the same tag.
We train embeddings using English wikipedia with the dataset used in (, and the Structured Skip-n-gram model. Results using pre-trained word lookup tables and the C2W with the pre-trained word lookup tables as additional parameters are shown in rows "word(sskip)" and "C2W + word(sskip)". We can observe that both systems can obtain improvements over their random initializations (rows "word" and (C2W)).
Finally, we also found that when using the C2W model in conjunction pre-trained word embeddings, that adding a non-linearity to the representations extracted from the C2W model e C w improves the results over using a simple linear trans-: POS accuracy result comparison with state-of-the-art systems for the English PTB.
formation (row "C2W(tanh)+word (sskip)"). This setup, obtains 0.28 points over the current state-ofthe-art system(row "SCCN").
section: Discussion
It is important to refer here that these results do not imply that our model always outperforms existing benchmarks, in fact inmost experiments, results are typically fairly similar to existing systems. Even in Turkish, using morphological analysers in order to extract additional features could also accomplish similar results. The goal of our work is not to overcome existing benchmarks, but show that much of the feature engineering done in the benchmarks can be learnt automatically from the task specific data. More importantly, we wish to show large dimensionality word look tables can be compacted into a lookup table using characters and a compositional model allowing the model scale better with the size of the training data. This is a desirable property of the model as data becomes more abundant in many NLP tasks.
section: Related Work
Our work, which learns representations without relying on word lookup tables has not been explored to our knowledge. In essence, our model attempts to learn lexical features automatically while compacting the model by reducing the redundancy found in word lookup tables. Individually, these problems have been the focus of research in many areas. Lexical information has been used to augment word lookup tables. Word representation learning can bethought of as a process that takes a string as input representing a word and outputs a set of values that represent a word in vector space. Using word lookup tables is one possible approach to accomplish this. Many methods have been used to augment this model to learn lexical features with an additional model that is jointly maximized with the word lookup table. This is generally accomplished by either performing a component-wise addition of the embeddings produced byword lookup tables, and that generated by the additional lexical model, or simply concatenating both representations (). Many models have been proposed, the work in) refers that additional features sets F i can be added to the one-hot representation and multiple lookup tables I F i can be learnt to project each of the feature sets to the same low-dimensional vector e W w . For instance, the work in shows that using morphological analyzers to generate morphological features, such as stems, prefixes and suffixes can be used to learn better representations for words. A problem with this approach is the fact that the model can only learn from what has been defined as feature sets. The models proposed in allow the model to arbitrary extract meaningful lexical features from words by defining compositional models over characters. The work in defines a simple compositional model by summing overall characters in a given word, while the work in) defines a convolutional network, which combines windows of characters and a max-pooling layer to find important morphological features. The main drawback of these methods is that character order is often neglected, that is, when summing overall character embeddings, words such as dog and god would have the same representation according to the lexical model. Convolutional model are less susceptible to these problems as they combine windows of characters at each convolution, where the order within the window is preserved. However, the order between extracted windows is not, so the problem still persists for longer words, such as those found in agglutinative languages. Yet, these approaches work in conjunction with a word lookup table, as they compensate for this inability. Aside from neural approaches, characterbased models have been applied to address multiple lexically oriented tasks, such as transliteration) and twitter normalization (.
Compacting models has been a focus of research in tasks, such as language modeling and machine translation, as extremely large models can be built with the large amounts of training data that are available in these tasks. In language modeling, it is frequent to prune higher order ngrams that do not encode any additional information (. The same be applied in machine translation () by removing longer translation pairs that can be replicated using smaller ones. In essence our model learns regularities at the subword level that can be leveraged for building more compact word representations.
Finally, our work has been applied to dependency parsing and found similar improvements over word models in morphologically rich languages ().
section: Conclusion
We propose a C2W model that builds word embeddings for words without an explicit word lookup table. Thus, it benefits from being sensitive to lexical aspects within words, as it takes characters as atomic units to derive the embeddings for the word. On POS tagging, our models using characters alone can still achieve comparable or better results than state-of-the-art systems, without the need to manually engineer such lexical features. Although both language modeling and POS tagging both benefit strongly from morphological cues, the success of our models in languages with impoverished morphological cues shows that it is able to learn non-compositional aspects of how letters fit together.
The code for the C2W model and our language model and POS tagger implementations is available from https://github.com/wlin12/ JNN.
