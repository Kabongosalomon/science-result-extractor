section: title
REACHING HUMAN-LEVEL PERFORMANCE IN AUTOMATIC GRAMMATICAL ERROR CORRECTION: AN EMPIRICAL STUDY
section: abstract
Neural sequence-to-sequence (seq2seq) approaches have proven to be successful in grammatical error correction (GEC). Based on the seq2seq framework, we propose a novel fluency boost learning and inference mechanism. Fluency boosting learning generates diverse error-corrected sentence pairs during training, enabling the error correction model to learn how to improve a sentence's fluency from more instances, while fluency boosting inference allows the model to correct a sentence incrementally with multiple inference steps. Combining fluency boost learning and inference with convolutional seq2seq models, our approach achieves the state-of-the-art performance: 75.72 (F 0.5) on CoNLL-2014 10 annotation dataset and 62.42 (GLEU) on JFLEG test set respectively, becoming the first GEC system that reaches human-level performance (72.58 for CoNLL and 62.37 for JFLEG) on both of the benchmarks.
section: INTRODUCTION
Sequence-to-sequence (seq2seq) models () for grammatical error correction (GEC) have drawn growing attention) in recent years. However, most of the seq2seq models for GEC have two flaws. First, the seq2seq models are trained with only limited error-corrected sentence pairs like(a). Limited by the size of training data, the models with millions of parameters may not be well generalized. Thus, it is common that the models fail to correct a sentence perfectly even if the sentence is slightly different from the training instance, as illustrated by. Second, the seq2seq models usually cannot perfectly correct a sentence with many grammatical errors through single-round seq2seq inference, as shown in(b) and 1(c), because some errors in a sentence may make the context strange, which confuses the models to correct other errors.
To address the above-mentioned limitations in model learning and inference, we propose a novel fluency boost learning and inference mechanism, illustrated in.
For fluency boosting learning, not only is a seq2seq model trained with original error-corrected sentence pairs, but also it generates less fluent sentences (e.g., from its n-best outputs) to establish new error-corrected sentence pairs by pairing them with their correct sentences during training, as long as the sentences' fluency 1 is below that of their correct sentences, as(a) shows. Specifically, we call the generated error-corrected sentence pairs fluency boost sentence pairs because the sentence in the target side always improves fluency over that in the source side. The generated fluency boost sentence pairs during training will be used as additional training instances during subsequent training epochs, allowing the error correction model to see more grammatically incorrect sentences during training and accordingly improving its generalization ability.
For model inference, fluency boost inference mechanism allows the model to correct a sentence incrementally with multi-round inference as long as the proposed edits can boost the sentence's She see Tom is catched by policeman in park at last night. She saw Tom caught by a policeman in the park last night.
She sees Tom is catched by policeman in park at last night.  Figure 1: (a) an error-corrected sentence pair; (b) if the sentence becomes slightly different, the model fails to correct it perfectly; (c) single-round seq2seq inference cannot perfectly correct the sentence, but multi-round inference can.
She see Tom is catched by policeman in park at last night.: Fluency boost learning and inference: (a) given a training instance (i.e., an error-corrected sentence pair), fluency boost learning establishes multiple fluency boost sentence pairs from the seq2seq's n-best outputs during training. The fluency boost sentence pairs will be used as training instances in subsequent training epochs, which helps expand the training set and accordingly benefits model learning; (b) fluency boost inference allows an error correction model to correct a sentence incrementally through multi-round seq2seq inference as long as its fluency can be improved. fluency, as(b) shows. For a sentence with multiple grammatical errors, some of the errors will be corrected first. The corrected parts will make the context clearer, which may benefit the model to correct the remaining errors. Moreover, based on the special characteristics of this task that the output prediction can be repeatedly edited and the basic fluency boost inference idea, we further propose a round-way correction approach that uses two seq2seq models whose decoding orders are left-to-right and right-to-left respectively. For round-way correction, a sentence will be corrected successively by the right-to-left and left-to-right seq2seq model 2 . Since the left-to-right and rightto-left decoder decode a sequence with different contexts, they have their unique advantages for specific error types. Round-way correction can fully exploit their pros and make them complement each other, which results in a significant improvement of recall.
Experiments show that combining fluency boost learning and inference with convolutional seq2seq models, our best GEC system 3 achieves 75.72 F 0.5 on CoNLL-2014 10 annotation dataset and 62.42 GLEU on JFLEG test set, becoming the first system reaching human-level performance on both of the GEC benchmarks.
section: BACKGROUND: NEURAL GRAMMATICAL ERROR CORRECTION
As neural machine translation (NMT), atypical neural GEC approach uses an encoder-decoder seq2seq model) with attention mechanism ( ) to edit a raw sentence into the grammatically correct sentence it should be, as(a) shows.
Given a raw sentence x r = (x r 1 , · · · , x r M ) and its corrected sentence x c = (x c 1 , · · · , x c N ) in which x r M and x c N are the M -th and N -th words of sentence x rand x c respectively, the error correction seq2seq model learns a probabilistic mapping P (x c |x r ) from error-corrected sentence pairs through maximum likelihood estimation (MLE), which learns model parameters Θ crt to maximize the following equation:
where S * denotes the set of error-corrected sentence pairs.
For model inference, an output sequence
is selected through beam search, which maximizes the following equation:
3 FLUENCY BOOST LEARNING Conventional seq2seq models for GEC learn model parameters only from original error-corrected sentence pairs. However, such error-corrected sentence pairs are not sufficiently available. As a result, many neural GEC models are not very well generalized.
Fortunately, neural GEC is different from NMT. For neural GEC, its goal is improving a sentence's fluency 4 without changing its original meaning; thus, any sentence pair that satisfies this condition (we call it fluency boost condition) can be used as a training instance.
In this work, we define f (x) as the fluency score of a sentence x:
where P (x i |x <i ) is the probability of xi given context x <i , computed by a language model, and |x| is the length of sentence x. H(x) is actually the cross entropy of the sentence x, whose range is
The core idea of fluency boost learning is to generate fluency boost sentence pairs that satisfy the fluency boost condition during training, as(a) illustrates, so that these pairs can further help model learning.
In this section, we present three fluency boost learning strategies: back-boost, self-boost, and dualboost that generate fluency boost sentence pairs in different ways, as illustrated in.
section: BACK-BOOST LEARNING
Back-boost learning borrows the idea from back translation () in NMT, referring to training a backward model (we call it error generation model, as opposed to error correction  model) that is used to convert a fluent sentence to a less fluent sentence with errors. Since the less fluent sentences are generated by the error generation seq2seq model trained with error-corrected data, they usually do not change the original sentence's meaning; thus, they can be paired with their correct sentences, establishing fluency boost sentence pairs that can be used as training instances for error correction models, as(a) shows.
Specifically, we first train a seq2seq error generation model Θ gen with S * which is identical to S * except that the source sentence and the target sentence are interchanged. Then, we use the model Θ gen to predict n-best outputs x o1 , · · · , x on given a correct sentence x c . Given the fluency boost condition, we compare the fluency of each output x ok (where 1 ≤ k ≤ n) to that of its correct sentence x c . If an output sentence's fluency score is much lower than its correct sentence, we call it a disfluency candidate of x c .
To formalize this process, we first define Y n (x; Θ) to denote the n-best outputs predicted by model Θ given the input x. Then, disfluency candidates of a correct sentence x c can be derived:
where D back (x c ) denotes the disfluency candidate set for x c in back-boost learning. σ is a threshold to determine if x ok is less fluent than x c and it should be slightly larger 5 than 1.0, which helps filter out sentence pairs with unnecessary edits (e.g., I like this book. → I like the book.).
In the subsequent training epochs, the error correction model will not only learn from the original error-corrected sentence pairs (x r ,x c ), but also learn from fluency boost sentence pairs (x ok ,x c ) where
We summarize this process in Algorithm 1 where S * is the set of original error-corrected sentence pairs, and Scan be tentatively considered identical to S * when there is no additional native data to help model training (see Section 3.4). Note that we constrain the size of St not to exceed |S * | (the 7th line in Algorithm 1) to avoid that too many fluency boost pairs overwhelm the effects of the original error-corrected pairs on model learning.
section: SELF-BOOST LEARNING
In contrast to back-boost learning whose core idea is originally from NMT, self-boost learning is original, which is specially devised for neural GEC. The idea of self-boost learning is illustrated by(b) and was already briefly introduced in Section 1 and(a). Unlike back-boost learning in which an error generation seq2seq model is trained to generate disfluency candidates, self-boost learning allows the error correction model to generate the candidates by itself. Since the Algorithm 1 Back-boost learning 1: Train error generation model Θ gen with S * ; 2: for each sentence pair (x r , x c ) ∈ S do 3:
Compute D back (x c ) according to Eq (5); 4: end for 5: for each training epoch t do
section: 6:
S ← ∅;
section: 7:
Derive a subset St by randomly sampling |S * | elements from S;
section: 8:
for each (x r , x c ) ∈ St do 9:
Establish a fluency boost pair (x , x c ) by randomly sampling x ∈ D back (x c );
section: 10:
S ← S ∪ {(x , x c )}; Update error correction model Θ crt with S * ∪ S ; 13: end for disfluency candidates generated by the error correction seq2seq model trained with error-corrected data rarely change the input sentence's meaning; thus, they can be used to establish fluency boost sentence pairs.
For self-boost learning, given an error corrected pair (x r , x c ), an error correction model Θ crt first predicts n-best outputs x o1 , · · · , x on for the raw sentence x r . Among the n-best outputs, any output that is not identical to x c can be considered as an error prediction. Instead of treating the error predictions useless, self-boost learning fully exploits them. Specifically, if an error prediction x ok is much less fluent than that of its correct sentence x c , it will be added to x c 's disfluency candidate set D self (x c ), as Eq shows:
In contrast to back-boost learning, self-boost generates disfluency candidates from a different perspective -by editing the raw sentence x r rather than the correct sentence x c . It is also noteworthy that D self (x c ) is incrementally expanded because the error correction model Θ crt is dynamically updated, as shown in Algorithm 2.
Algorithm 2 Self-boost learning 1: for each sentence pair (x r , x c ) ∈ S do 2: Derive a subset St by randomly sampling |S * | elements from S;
section: 9:
for each (x r , x c ) ∈ St do 10:
Update D self (x c ) according to Eq (6);
section: 11:
Establish a fluency boost pair (x , x c ) by randomly sampling x ∈ D self (x c );
section: 12:
S ← S ∪ {(x , x c )};
section: 13:
end for 14: end for
section: DUAL-BOOST LEARNING
As introduced above, back-and self-boost learning generate disfluency candidates from different perspectives to create more fluency boost sentence pairs to benefit training the error correction model. Intuitively, the more diverse disfluency candidates generated, the more helpful for training an error correction model. Inspired by and, we propose a dual-boost learning strategy, combining both back-and self-boost's perspectives to generate disfluency candidates.
section: Algorithm 3 Dual-boost learning
1: for each (x r , x c ) ∈ S do 2:
D dual (x c ) ← ∅; 3: end for 4: S ← ∅; S ← ∅; 5: for each training epoch t do
section: 6:
Update error correction model Θ crt with S * ∪ S ;
section: 7:
Update error generation model Θ gen with S * ∪ S ;
8:
S ← ∅; S ← ∅;
9:
Derive a subset St by randomly sampling |S * | elements from S;
section: 10:
for each (x r , x c ) ∈ St do 11:
Update D dual (x c ) according to Eq (7); 12:
Establish a fluency boost pair (x , x c ) by randomly sampling x ∈ D dual (x c );
section: 13:
S ← S ∪ {(x , x c )};
14:
Establish a reversed fluency boost pair (x c , x ) by randomly sampling x ∈ D dual (x c );
section: 15:
S ← S ∪ {(x c , x )};
Moreover, the error correction model and the error generation model are dual and both of them are dynamically updated, which improves each other: the disfluency candidates produced by error generation model can benefit training the error correction model, while the disfluency candidates created by error correction model can be used as training data for the error generation model. We summarize this learning approach in Algorithm 3.
section: FLUENCY BOOST LEARNING WITH LARGE-SCALE NATIVE DATA
Our proposed fluency boost learning strategies can be easily extended to utilize massive native text data which proved to be useful for GEC.
As discussed in Section 3.1, when there is no additional native data, S in Algorithm 1-3 is identical to S * . In the case where additional native data is available to help model learning, S becomes:
where C = {(x c , x c )} denotes the set of self-copied sentence pairs from native data.
section: FLUENCY BOOST INFERENCE
section: MULTI-ROUND ERROR CORRECTION
As we discuss in Section 1, some sentences with multiple grammatical errors usually cannot be perfectly corrected through normal seq2seq inference which makes only single-round inference. Fortunately, neural GEC is different from NMT: its source and target language are the same. The characteristic allows us to edit a sentence more than once through multi-round model inference, which motivates our fluency boost inference. As(b) shows, fluency boost inference allows a sentence to be incrementally edited through multi-round seq2seq inference as long as the sentence's fluency can be improved. Specifically, an error correction seq2seq model first takes a raw sentence x r as an input and outputs a hypothesis x o1 . Instead of regarding x o1 as the final prediction, fluency boost inference will then take x o1 as the input to generate the next output x o2 . The process will not terminate unless x ot does not improve x o t−1 in terms of fluency.
She likes playing in park and come here every week.
She likes playing in the park and come here every week.
She likes playing in the park and comes here every week.
right-to-left left-to-right: Round-way error correction: some types of errors (e.g., articles) are easier to be corrected by a right-to-left seq2seq model, while some (e.g., subject verb agreement) are more likely to be corrected by a left-to-right seq2seq model. Round-way error correction makes left-to-right and right-to-left seq2seq models well complement each other, enabling it to correct more grammatical errors than an individual model.
section: ROUND-WAY ERROR CORRECTION
Based on the idea of multi-round correction, we further propose an advanced fluency boost inference approach: round-way error correction. Instead of progressively correcting a sentence with the same seq2seq model as introduced in Section 4.1, round-way correction corrects a sentence through a right-to-left seq2seq model and a left-to-right seq2seq model successively, as shown in.
The motivation of round-way error correction is straightforward. Decoders with different decoding orders decode word sequences with different contexts, making them have their unique advantages for specific error types. For the example in, the error of alack of an article (i.e., park → the park) is more likely to be corrected by the right-to-left seq2seq model than the left-to-right one, because whether to add an article depends on the noun park that was already seen by the right-to-left model when it made the decision. In contrast, the left-to-right model might be better at dealing with subject-verb agreement errors (e.g., come → comes in) because the keyword that decides the verb form is its subject She which is at the beginning of the sentence. that contains 10 human expert annotations for each test sentence. We evaluate systems' performance using both annotation settings for the CoNLL dataset. To distinguish between these two annotation settings, we use CoNLL-2014 to denote the original annotations, and CoNLL-10 to denote the 10-human annotations. As previous studies, we use CoNLL-2013 test set and JFLEG dev set as our development sets for CoNLL-2014 and JFLEG test set respectively.
section: EXPERIMENTS
section: DATASET AND EVALUATION
section: Corpus #sent pair
section: EXPERIMENTAL SETTING
We use 7-layer convolutional seq2seq models as our error correction and error generation model, which have proven to be effective for GEC., we set the dimensionality of word embeddings in both encoders and decoders to 500, the hidden size of encoders and decoders to 1,024 and the convolution window width to 3. The vocabularies of the source and target side are the most frequent 30K BPE tokens for each. We train the seq2seq models using Nesterov Accelerated Gradient () optimizer with a momentum value of 0.99. The initial learning rate is set to 0.25 and it will be reduced by an order of magnitude if the validation perplexity stops improving. During training, we allow each batch to have at most 3,000 tokens per GPU and set dropout rate to 0.2. We terminate the training process when the learning rate falls below 10 −4 . As and , we train 4 models with different random initializations for ensemble decoding.
For fluency boost learning, we adopt dual-boost learning introduced in Section 3.3 and use the English Wikipedia data as our native data (Section 3.4). Disfluency candidates are generated from 10-best outputs. For fluency boost inference, we use round-way correction approach introduced in Section 4.2. The architecture of the right-to-left seq2seq model in round-way correction is the same with the left-to-right 7 one except that they decode sentences in the opposite directions. For singleround inference, we follow to generate 12-best predictions and choose the best sentence after re-ranking with edit operation and language model scores. The language model is the 5-gram language model trained on Common Crawl released by, which is also used for computing fluency score in Eq (3).
As most of the systems) evaluated on JFLEG that use an additional spellchecker to resolve spelling errors, we use a public spellchecker 8 to resolve spelling errors in JFLEG as preprocessing.
section: EXPERIMENTAL RESULTS
We compare our systems 9 to the following well-known GEC systems:
• CAMB14, CAMB16 and CAMB17: GEC systems () developed by Cambridge University. For CAMB17, we report its best result.
• CUUI and VT16: the former system () uses a classifier-based approach, which is improved by the latter system) through combining it with an SMT-based approach.
• AMU14 and AMU16: SMT-based GEC systems) developed by AMU.
• NUS14, NUS16, NUS17 and NUS18: The first three GEC systems ( are SMT-based GEC systems that are combined with other techniques (e.g., classifiers). The last one) uses convolutional seq2seq models for grammatical error correction.: Evaluation result analysis for top-performing GEC systems on CoNLL and JFLEG datasets.
The results marked with red font exceed the human-level performance.
• Nested-RNN-seq2seq: a Recurrent Neural Network (RNN) seq2seq model with nested attention ().
• Back-CNN-seq2seq: a convolutional seq2seq model () trained with synthesized data augmented by back translation. Its core idea is somewhat similar to the idea introduced in Section 3.1 and Section 3.4 of this work.
• Adapted-transformer: a transformer (Vaswani et al., 2017) based GEC system (JunczysDowmunt et al., 2018) with techniques adapted from low-resource machine translation.
• SMT-NMT hybrid: the state-of-the-art GEC system  that is based on an SMT-NMT hybrid approach.  We compare our systems to human performance on CoNLL-10 and JFLEG benchmarks. For CoNLL-10, we follow the evaluation setting in and to fairly compare systems' performance to human's, which is marked with (SvH) in. Among our systems, the system with fluency boost learning and inference outperforms human's performance on both CoNLL and JFLEG dataset, while the system with only fluency boost learning achieves higher F 0.5 scores on CoNLL dataset.
We further study the effectiveness of fluency boost learning and inference for different error types. shows the recall of base convolutional seq2seq model and the model trained with fluency boost learning for each error type 11 in CoNLL-2014 dataset (original annotation setting). One can see that fluency boost learning improves recall for most error types, demonstrating that fluency boost learning approach can generate sentences with diverse errors to help training.
To better understand the effectiveness of fluency boost inference (i.e., round-way error correction), we show in the recall of each error type of the left-to-right and the right-to-left seq2seq in CoNLL-2014 dataset (original annotation setting). Note that to clearly see pros and cons of the left-to-right and right-to-left model, here we do not re-rank their n-best results using edit operations and the language model; instead, we directly use their 1-best generated sentence as their prediction.
According to, the right-to-left model does better in the error types like ArtOrDet, while the left-to-right model is better at correcting the errors like SVA, which is consistent with our motivation in Section 4.2. When we use round-way correction, the errors that are not corrected by the rightto-left model are likely to be corrected by the left-to-right one, which is reflected by the recall improvement of most error types, as shown in.
section: RELATED WORK
Most of advanced GEC systems are classifier-based ( or MT-based (. For example, top-performing systems) in CoNLL-2014 shared task ( ) use either of the methods. Recently, many novel approaches () have been proposed for GEC. Among them, seq2seq models) have caught much attention. Unlike the models trained only with original error-corrected data, we propose a novel fluency boost learning mechanism for dynamic data augmentation along with training for GEC, despite some related studies that explore artificial error generation for GEC). Moreover, we propose fluency boost inference which allows the model to repeatedly edit a sentence as long as the sentence's fluency can be improved. To the best of our knowledge, it is the first to conduct multi-round seq2seq inference for GEC, while similar ideas have been proposed for NMT).
In addition to the studies on GEC, there is also much research on grammatical error detection ( and GEC evaluation). We do not introduce them in detail because they are not much related to this work's contributions.
section: CONCLUSION
We present a state-of-the-art convolutional seq2seq model based GEC system that uses a novel fluency boost learning and inference mechanism. Fluency boost learning fully exploits both errorcorrected data and native data by generating diverse error-corrected sentence pairs during training, which benefits model learning and improves the performance over the base seq2seq model, while fluency boost inference utilizes the characteristic of GEC to progressively improve a sentence's fluency through round-way correction. The powerful learning and inference mechanism enables our system to achieve state-of-the-art results and reach human-level performance on both CoNLL-2014 and JFLEG benchmark datasets.
