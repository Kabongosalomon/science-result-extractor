section: title
Fast-Slow Recurrent Neural Networks
section: abstract
Processing sequential data of variable length is a major challenge in a wide range of applications, such as speech recognition, language modeling, generative image modeling and machine translation. Here, we address this challenge by proposing a novel recurrent neural network (RNN) architecture, the Fast-Slow RNN (FS-RNN). The FS-RNN incorporates the strengths of both multiscale RNNs and deep transition RNNs as it processes sequential data on different timescales and learns complex transition functions from onetime step to the next. We evaluate the FS-RNN on two character level language modeling data sets, Penn Treebank and Hutter Prize Wikipedia, where we improve state of the art results to 1.19 and 1.25 bits-per-character (BPC), respectively. In addition, an ensemble of two FS-RNNs achieves 1.20 BPC on Hutter Prize Wikipedia outperforming the best known compression algorithm with respect to the BPC measure. We also present an empirical investigation of the learning and network dynamics of the FS-RNN, which explains the improved performance compared to other RNN architectures. Our approach is general as any kind of RNN cell is a possible building block for the FS-RNN architecture, and thus can be flexibly applied to different tasks.
section: Introduction
Processing, modeling and predicting sequential data of variable length is a major challenge in the field of machine learning. In recent years, recurrent neural networks (RNNs) have been the most popular tool to approach this challenge. RNNs have been successfully applied to improve state of the art results in complex tasks like language modeling and speech recognition. A popular variation of RNNs are long short-term memories (LSTMs), which have been proposed to address the vanishing gradient problem. LSTMs maintain constant error flow and thus are more suitable to learn long-term dependencies compared to standard RNNs.
Our work contributes to the ongoing debate on how to interconnect several RNN cells with the goals of promoting the learning of long-term dependencies, favoring efficient hierarchical representations of information, exploiting the computational advantages of deep over shallow networks and increasing computational efficiency of training and testing. In deep RNN architectures, RNNs or LSTMs are stacked layer-wise on top of each other. The additional layers enable the network to learn complex input to output relations and encourage a efficient hierarchical representation of information. In multiscale RNN architectures, the operation on different timescales is enforced by updating the higher layers less frequently, which further encourages an efficient hierarchical representation of information. The slower update rate of higher layers leads to computationally efficient implementations and gives rise to short gradient paths that favor the learning of long-term dependencies. In deep transition RNN architectures, intermediate sequentially connected layers are interposed between two consecutive hidden states in order to increase the depth of the transition function from onetime step to the next, as for example in deep transition networks or Recurrent Highway Networks (RHN). The intermediate layers enable the network to learn complex non-linear transition functions. Thus, the model exploits the fact that deep models can represent some functions exponentially more efficiently than shallow models. We interpret these networks as shallow networks that share the hidden state, rather than a single deep network. Despite being the same in practice, this interpretation makes it trivial to convert any RNN cell to a deep RNN by connecting the cells sequentially, see.
Here, we propose the Fast-Slow RNN (FS-RNN) architecture, a novel way of interconnecting RNN cells, that combines advantages of multiscale RNNs and deep transition RNNs. In its simplest form the architecture consists of two sequentially connected, fast operating RNN cells in the lower hierarchical layer and a slow operating RNN cell in the higher hierarchical layer, see and Section 3. We evaluate the FS-RNN on two standard character level language modeling data sets, namely Penn Treebank and Hutter Prize Wikipedia. Additionally, following, we present an empirical analysis that reveals advantages of the FS-RNN architecture over other RNN architectures.
The main contributions of this paper are:
• We propose the FS-RNN as a novel RNN architecture.
• We improve state of the art results on the Penn Treebank and Hutter Prize Wikipedia data sets.
• We surpass the BPC performance of the best known text compression algorithm evaluated on Hutter Prize Wikipedia by using an ensemble of two FS-RNNs.
• We show empirically that the FS-RNN incorporates strengths of both multiscale RNNs and deep transition RNNs, as it stores long-term dependencies efficiently and it adapts quickly to unexpected input.
• We provide our code in the following URL https://github.com/amujika/Fast-Slow-LSTM.
section: Related work
In the following, we review the work that relates to our approach in more detail. First, we focus on deep transition RNNs and multiscale RNNs since these two architectures are the main sources of inspiration for the FS-RNN architecture. Then, we discuss how our approach differs from these two architectures. Finally, we review other approaches that address the issue of learning long-term dependencies when processing sequential data.
Pascanu et al. investigated how a RNN can be converted into a deep RNN. In standard RNNs, the transition function from one hidden state to the next is shallow, that is, the function can be written as one linear transformation concatenated with a point wise non-linearity. The authors added intermediate layers to increase the depth of the transition function, and they found empirically that such deeper architectures boost performance. Since deeper architectures are more difficult to train, they equip the network with skip connections, which give rise to shorter gradient paths (DT(S)-RNN, see). Following a similar line of research, Zilly et al. further increased the transition depth between two consecutive hidden states. They used highway layers to address the issue of training deep architectures. The resulting RHN achieved state of the art results on the Penn Treebank and Hutter Prize Wikipedia data sets. Furthermore, a vague similarity to deep transition networks can be seen in adaptive computation, where an LSTM cell learns how many times it should update its state after receiving the input to produce the next output.
Multiscale RNNs are obtained by stacking multiple RNNs with decreasing order of update frequencies on top of each other. Early attempts proposed such architectures for sequential data compression, where the higher layer is only updated in case of prediction errors of the lower layer, and for sequence classification, where the higher layers are updated with a fixed smaller frequency. More recently, Koutnik et al. proposed the Clockwork RNN, in which the hidden units are divided into several modules, of which the i-th module is only updated every 2 i -th time-step. General advantages of this multiscale RNN architecture are improved computational efficiency, efficient propagation of long-term dependencies and flexibility in allocating resources (units) to the hierarchical layers. Multiscale RNNs have been applied for speech recognition in, where the slower operating RNN pools information overtime and the timescales are fixed hyperparameters as in Clockwork RNNs.
In, multiscale RNNs are applied to make context-aware query suggestions. In this case, explicit hierarchical boundary information is provided. Chung et al. presented a hierarchical multiscale RNN (HM-RNN) that discovers the latent hierarchical structure of the sequence without explicitly given boundary information. If a parametrized boundary detector indicates the end of a segment, then a summarized representation of the segment is fed to the upper layer and the state of the lower layer is reset.
Our FS-RNN architectures borrows elements from both deep transition RNNs and multiscale RNNs. The major difference to multiscale RNNs is that our lower hierarchical layer zooms in in time, that is, it operates faster than the timescale that is naturally given by the input sequence. The major difference to deep transition RNNs is our approach to facilitate long-term dependencies, namely, we employ a RNN operating on a slow timescale.
Many approaches aim at solving the problem of learning long-term dependencies in sequential data.
The output y t is computed as an affine transformation of h F kt . It is possible to extend the FS-RNN architecture in order to further facilitate the learning of long-term dependencies by adding hierarchical layers, each of which operates on a slower timescale than the ones below, resembling clockwork RNNs. However, for the tasks considered in Section 4, we observed that this led to overfitting the training data even when applying regularization techniques and reduced the performance attest time. Therefore, we will not further investigate this extension of the model in this paper, even though it might be beneficial for other tasks or larger data sets.
In the experiments in Section 4, we use LSTM cells as building blocks for the FS-RNN architecture. For completeness, we state the update function f Q for an LSTM Q. The state of an LSTM is a pair (h t , ct ), consisting of the hidden state and the cell state. The function f Q maps the previous state and input (h t−1 , c t−1 , x t ) to the next state (h t , ct ) according to
where ft , it and o tare commonly referred to as forget, input and output gates, and gt are the new candidate cell states. Moreover, W Q h , W Q x and b Q are the learnable parameters, σ denotes the sigmoid function, and ⊙ denotes the element-wise multiplication.
section: Experiments
For the experiments, we consider the Fast-Slow LSTM (FS-LSTM) that is a FS-RNN, where each RNN cell is a LSTM cell. The FS-LSTM is evaluated on two character level language modeling data sets, namely Penn Treebank and Hutter Prize Wikipedia, which will be referred to as enwik8 in this section. The task consists of predicting the probability distribution of the next character given all the previous ones. In Section 4.1, we compare the performance of the FS-LSTM with other approaches. In Section 4.2, we empirically compare the network dynamics of different RNN architectures and show the FS-LSTM combines the benefits of both, deep transition RNNs and multiscale RNNs.
section: Performance on Penn Treebank and Hutter Prize Wikipedia
The FS-LSTM achieves 1.19 BPC and 1.25 BPC on the Penn Treebank and enwik8 data sets, respectively. These results are compared to other approaches in (the baseline LSTM results without citations are taken from for Penn Treebank and from for enwik8). For the Penn Treebank, the FS-LSTM outperforms all previous approaches with significantly less parameters than the previous top approaches. We did not observe any improvement when increasing the model size, probably due to overfitting. In the enwik8 data set, the FS-LSTM surpasses all other neural approaches. Following, we compare the results with text compression algorithms using the BPC measure. An ensemble of two FS-LSTM models (1.20 BPC) outperforms cmix (1.23 BPC), the current best text compression algorithm on enwik8. However, a fair comparison is difficult. Compression algorithms are usually evaluated by the final size of the compressed data set including the decompressor size. For character prediction models, the network size is usually not taken into account and the performance is measured on the test set. We remark that as the FS-LSTM is evaluated on the test set, it should achieve similar performance on any part of the English Wikipedia. The model is trained to minimize the cross-entropy loss between the predictions and the training data. Formally, the loss function is defined as L = − 1 n n i=1 log p θ (x i |x 1 , . . . , x i−1 ), where p θ (x i |x 1 , . . . , x i−1 ) is the probability that a model with parameters θ assigns to the next character xi given all the previous ones. The model is evaluated by the BPC measure, which uses the binary logarithm instead of the natural logarithm in the loss function. All the hyperparameters used for the experiments are summarized in. We regularize the FS-LSTM with dropout. In each time step, a different dropout mask is applied for the non-recurrent connections, and Zoneout is applied for the recurrent connections. The network is trained with minibatch gradient descent using the Adam optimizer. If the gradients have norm larger than 1 they are normalized to 1. Truncated backpropagation through time (TBPTT) is used to approximate the gradients, and the final hidden state is passed to the next sequence. The learning rate is divided by a factor 10 for the last 20 epochs in the Penn Treebank experiments, and it is divided by a factor 10 whenever the validation error does not improve in two consecutive epochs in the enwik8 experiments. The forget bias of every LSTM cell is initialized to 1, and all weight matrices are initialized to orthogonal matrices. Layer normalization is applied to the cell and to each gate separately. The network with the smallest validation error is evaluated on the test set. The two data sets that we use for evaluation are:
The dataset is a collection of Wall Street Journal articles written in English. It only contains 10000 different words, all written in lower-case, and rare words are replaced with "< unk >". Following, we split the data set into train, validation and test sets consisting of 5.1M, 400K and 450K characters, respectively.
Hutter Prize Wikipedia This dataset is also known as enwik8 and it consists of "raw" Wikipedia data, that is, English articles, tables, XML data, hyperlinks and special characters. The data set contains 100M characters with 205 unique tokens. Following, we split the data set into train, validation and test sets consisting of 90M, 5M and 5M characters, respectively.
section: Comparison of network dynamics of different architectures
We compare the FS-LSTM architecture with the stacked-LSTM and the sequential-LSTM architectures, depicted in, by investigating the network dynamics. In order to conduct a fair comparison we chose the number of parameters to roughly be the same for all three models. The FS-LSTM consists of one Slow and four Fast LSTM cells of 450 units each. The stacked-LSTM consists of five LSTM cells stacked on top of each other consisting of 375 units each, which will be  referred to as Stacked-1, ... , Stacked-5, from bottom to top. The sequential-LSTM consists of five sequentially connected LSTM cells of 500 units each. All three models require roughly the same time to process onetime step. The models are trained on enwik8 for 20 epochs with minibatch gradient descent using the Adam optimizer without any regularization, but layer normalization is applied on the cell states of the LSTMs. The hyperparameters are not optimized for any of the three models.
The experiments suggest that the FS-LSTM architecture favors the learning of long-term dependencies), enforces hidden cell states to change at different rates () and facilitates a quick adaptation to unexpected inputs (. Moreover, the FS-LSTM achieves 1.49 BPC and outperforms the stacked-LSTM (1.61 BPC) and the sequential-LSTM (1.58 BPC).
In, we asses the ability to capture long-term dependencies by investigating the effect of the cell state on the loss at later time points, following. We measure the effect of the cell state at time t − k on the loss at time t by the gradient ∂Lt
. This gradient is the largest for the Slow LSTM, and it is small and steeply decaying ask increases for the Fast LSTM. Evidently, the Slow cell captures long-term dependencies, whereas the Fast cell only stores short-term information. In the stacked-LSTM, the gradients decrease from the top layer to the bottom layer, which can be explained by the vanishing gradient problem. The small, steeply decaying gradients of the sequential-LSTM indicate that it is less capable to learn long-term dependencies than the other two models. gives further evidence that the FS-LSTM stores long-term dependencies efficiently in the Slow LSTM cell. It shows that among all the layers of the three RNN architectures, the cell states of the Slow LSTM change the least from onetime step to the next. The highest change is observed for the cells of the sequential model followed by the Fast LSTM cells.
In, we investigate whether the FS-LSTM quickly adapts to unexpected characters, that is, whether it performs well on the subsequent ones. In text modeling, the initial character of a word has the highest entropy, whereas later characters in a word are usually less ambiguous. Since the first character of a word is the most difficult one to predict, the performance at the following positions should reflect the ability to adapt to unexpected inputs. While the prediction qualities at the first position are rather close for all three models, the FS-LSTM outperforms the stacked-LSTM and sequential-LSTM significantly on subsequent positions. It is possible that new information is incorporated quickly in the Fast layer, because it only stores short-term information, see. Rate of change Sequential FS-Fast FS-Slow Stacked-1 Stacked-2 Stacked-3 Stacked-4 Stacked-5: Rate of change of the cell states from onetime step to the next. We plot 1 n n i=1 (c t,i − c t−1,i ) 2 averaged overall time steps, where c t,i is the value of the ith unit at time step t, for the different layers of the three RNN architectures. For the sequential-LSTM only the first cell is considered.
section: Conclusion
In this paper, we have proposed the FS-RNN architecture. Up to our knowledge, it is the first architecture that incorporates ideas of both multiscale and deep transition RNNs. The FS-RNN architecture improved state of the art results on character level language modeling evaluated on the Penn Treebank and Hutter Prize Wikipedia data sets. An ensemble of two FS-RNNs achieves better BPC performance than the best known compression algorithm. Further experiments provided evidence that the Slow cell enables the network to learn long-term dependencies, while the Fast cells enable the network to quickly adapt to unexpected inputs and learn complex transition functions from onetime step to the next.
Our FS-RNN architecture provides a general framework for connecting RNN cells as any type of RNN cell can be used as building block. Thus, there is a lot of flexibility in applying the architecture to different tasks. For instance using RNN cells with good long-term memory, like EURNNs or NARX RNNs, for the Slow cell might boost the long-term memory of the FS-RNN architecture. Therefore, the FS-RNN architecture might improve performance in many different applications.
