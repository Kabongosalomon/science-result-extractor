section: title
Convolutional 2D Knowledge Graph Embeddings
section: abstract
Link prediction for knowledge graphs is the task of predicting missing relationships between entities. Previous work on link prediction has focused on shallow, fast models which can scale to large knowledge graphs. However, these models learn less expressive features than deep, multi-layer models-which potentially limits performance. In this work we introduce ConvE, a multi-layer convolutional network model for link prediction, and report state-of-the-art results for several established datasets. We also show that the model is highly parameter efficient, yielding the same performance as DistMult and R-GCN with 8x and 17x fewer parameters. Analysis of our model suggests that it is particularly effective at modelling nodes with high indegree-which are common in highly-connected, complex knowledge graphs such as Freebase and YAGO3. In addition, it has been noted that the WN18 and FB15k datasets suffer from test set leakage, due to inverse relations from the training set being present in the test set-however, the extent of this issue has so far not been quantified. We find this problem to be severe: a simple rule-based model can achieve state-of-the-art results on both WN18 and FB15k. To ensure that models are evaluated on datasets where simply exploiting inverse relations cannot yield competitive results, we investigate and validate several commonly used datasets-deriving robust variants where necessary. We then perform experiments on these robust datasets for our own and several previously proposed models, and find that ConvE achieves state-of-the-art Mean Reciprocal Rank across most datasets.
section: Specifically, our contributions are as follows:
• Introducing a simple, competitive 2D convolutional link prediction model, ConvE.
• Developing a 1-N scoring procedure that speeds up training three-fold and evaluation by 300x.
• Establishing that our model is highly parameter efficient, achieving better scores than DistMult and R-GCNs on FB15k-237 with 8x and 17x fewer parameters.
• Showing that for increasingly complex knowledge graphs, as measured by indegree and PageRank, the difference in performance between our model and a shallow model increases proportionally to the complexity of the graph.
• Systematically investigating reported inverse relations test set leakage across commonly used link prediction datasets, introducing robust versions of datasets where necessary, so that they cannot be solved using simple rule-based models.
• Evaluating ConvE and several previously proposed models on these robust datasets: our model achieves state-of-theart Mean Reciprocal Rank across most of them., which uses cross-correlation -the inverse of circular convolution -for matching entity embeddings; it is inspired by holographic models of associative memory. However, HolE does not learn multiple layers of non-linear features, and it is thus theoretically less expressive than our model. To the best of our knowledge, our model is the first neural link prediction model to use 2D convolutional layers. Graph Convolutional Networks (GCNs) ( area related line of research, where the convolution operator is generalised to use locality information in graphs. However, the GCN framework is limited to undirected graphs, while knowledge graphs are naturally directed, and suffers from potentially prohibitive memory requirements (. Relational GCNs (R-GCNs) () area generalisation of GCNs developed for dealing with highly multi-relational data such as knowledge graphs -we include them in our experimental evaluations.
section: Related Work
Several convolutional models have been proposed in natural language processing (NLP) for solving a variety of tasks, including semantic parsing (), sentence classification), search query retrieval (), sentence modelling, as well as other NLP tasks (). However, most work in NLP uses 1D-convolutions, that is convolutions which operate over a temporal sequence of embeddings, for example a sequence of words in embedding space. In this work, we use 2D-convolutions which operate spatially over embeddings.
section: Number of Interactions for 1D vs 2D Convolutions
Using 2D rather than 1D convolutions increases the expressiveness of our model through additional points of interaction between embeddings. For example, consider the case where we concatenate two rows of 1D embeddings, a and b with dimension n = 3:
A padded 1D convolution with filter size k = 3 will be able to model the interactions between these two embeddings around the concatenation point (with a number of interactions proportional to k).
If we concatenate (i.e. stack) two rows of 2D embeddings with dimension m × n, where m = 2 and n = 3, we obtain the following:
a a a a a a ;
A padded 2D convolution with filter size 3 × 3 will be able to model the interactions around the entire concatenation line (with a number of interactions proportional ton and k).
We can extend this principle to an alternating pattern, such as the following:
In this case, a 2D convolution operation is able to model even more interactions between a and b (with a number of interactions proportional tom, n, and k). Thus, 2D convolution is able to extract more feature interactions between two embeddings compared to 1D convolution. The same principle can be extending to higher dimensional convolutions, but we leave this as future work.
section: Background
A knowledge graph G = {(s, r, o)} ⊆ E × R × E can be formalised as a set of triples (facts), each consisting of a relationship r ∈ Rand two entities s, o ∈ E, referred to as the subject and object of the triple. Each triple (s, r, o) denotes a relationship of type r between the entities sand o.
The link prediction problem can be formalised as a pointwise learning to rank problem, where the objective is learning a scoring function ψ : E × R × E → R. Given an input triplex = (s, r, o), its score ψ(x) ∈ R is proportional to the likelihood that the fact encoded by x is true.
section: Neural Link Predictors
Neural link prediction models ( ) can be seen as multi-layer neural networks consisting of an encoding component and a scoring component. Given an input triple (s, r, o), the encoding component maps entities s, o ∈ E to their distributed embedding representations e s , e o ∈ R k . In: Scoring functions ψ r (e s , e o ) from neural link predictors in the literature, their relation-dependent parameters and space complexity; n e and n r respectively denote the number of entities and relation types, i.e. n e = |E| and n r = |R|.
section: Model
Scoring Function ψ r (e s , e o ) Relation Parameters Space Complexity SE ()
the scoring component, the two entity embeddings e sand e o are scored by a function ψ r . The score of a triple
In we summarise the scoring function of several link prediction models from the literature. The vectors e sand e o denote the subject and object embedding, where e s , e o ∈ C kin ComplEx and e s , e o ∈ R kin all other models, and x, y, z = ix i y i z i denotes the tri-linear dot product; * denotes the convolution operator; f denotes a non-linear function.
section: Convolutional 2D Knowledge Graphs Embeddings
In this work we propose a neural link prediction model where the interactions between input entities and relationships are modelled by convolutional and fully-connected layers. The main characteristic of our model is that the score is defined by a convolution over 2D shaped embeddings. The architecture is summarised in; formally, the scoring function is defined as follows:
where r r ∈ R k is a relation parameter depending on r, e sand r r denote a 2D reshaping of e sand r r , respectively: if e s , r r ∈ R k , then e s , r r ∈ R kw×k h , where k = kw k h . In the feed-forward pass, the model performs a row-vector look-up operation on two embedding matrices, one for entities, denoted E |E|×k and one for relations, denoted R |R|×k , where k and k are the entity and relation embedding dimensions, and |E| and |R| denote the number of entities and relations. The model then concatenates e sand r r , and uses it as an input fora 2D convolutional layer with filters ω. Such a layer returns a feature map tensor T ∈ R c×m×n , where c is the number of 2D feature maps with dimensions m and n. The tensor T is then reshaped into a vector vec(T ) ∈ R cmn , which is then projected into a k-dimensional space using a linear transformation parametrised by the matrix W ∈ R cmn×k and matched with the object embedding e o via an inner product. The parameters of the convolutional filters and the matrix Ware independent of the parameters for the entities sand o and the relationship r.
For training the model parameters, we apply the logistic sigmoid function σ(·) to the scores, that is p = σ(ψ r (e s , e o )), and minimise the following binary crossentropy loss:
where t is the label vector with dimension R 1x1 for 1-1 scoring or R 1xN for 1-N scoring (see the next section for 1-N scoring); the elements of vector tare ones for relationships that exists and zero otherwise. We use rectified linear units as the non-linearity f for faster training, and batch normalisation after each layer to stabilise, regularise and increase rate of convergence. We regularise our model by using dropout) in several stages. In particular, we use dropout on the embeddings, on the feature maps after the convolution operation, and on the hidden units after the fully connected layer. We use Adam as optimiser (, and label smoothing to lessen overfitting due to saturation of output non-linearities at the labels ().
section: Fast Evaluation for Link Prediction Tasks
In our architecture convolution consumes about 75-90% of the total computation time, thus it is important to minimise the number of convolution operations to speedup computation as much as possible. For link prediction models, the batch size is usually increased to speedup evaluation (). However, this is not feasible for convolutional models since the memory requirements quickly outgrow the GPU memory capacity when increasing the batch size.
Unlike other link prediction models which take an entity pair and a relation as a triple (s, r, o), and score it (1-1 scoring), we take one (s, r) pair and score it against all entities o ∈ E simultaneously (1-N scoring). If we benchmark 1-1 scoring on a high-end GPU with batch size and embedding size 128, then a training pass and an evaluation with a convolution model on FB15k -one of the dataset used in the experiments -takes 2.4 minutes and 3.34 hours. Using 1-N scoring, the respective numbers are 45 and 35 seconds -a considerable improvement of over 300x in terms of evaluation time. Additionally, this approach is scalable to large knowledge graphs and increases convergence speed. For a single forward-backward pass with batch size of 128, going from N = 100, 000 to N = 1, 000, 000 entities only increases the computational time from 64ms to 80ms -in other words, a ten-fold increase in the number of entities only increases the computation time by 25% -which attests the scalability of the approach.  In the ConvE model, the entity and relation embeddings are first reshaped and concatenated (steps 1, 2); the resulting matrix is then used as input to a convolutional layer (step 3); the resulting feature map tensor is vectorised and projected into a k-dimensional space (step 4) and matched with all candidate object embeddings (step 5). If instead of 1-N scoring, we use 1-(0.1N) scoring -that is, scoring against 10% of the entities -we can compute a forward-backward pass 25% faster. However, we converge roughly 230% slower on the training set. Thus 1-N scoring has an additional effect which is akin to batch normalisation (Ioffe and Szegedy 2015) -we trade some computational performance for greatly increased convergence speed and also achieve better performance as shown in Section 7. Do note that the technique in general could by applied to any 1-1 scoring model. This practical trick in speeding up training and evaluation can be applied to any 1-1 scoring model, such as the great majority of link prediction models.
section: Experiments
section: Knowledge Graph Datasets
For evaluating our proposed model, we use a selection of link prediction datasets from the literature.
WN18 () is a subset of WordNet which consists of 18 relations and 40,943 entities. Most of the 151,442 triples consist of hyponym and hypernym relations and, for such a reason, WN18 tends to follow a strictly hierarchical structure. Countries (Bouchard, Singh, and Trouillon 2015) is a benchmark dataset that is useful to evaluate a model's ability to learn long-range dependencies between entities and relations. It consists of three sub-tasks which increase in difficulty in a step-wise fashion, where the minimum pathlength to find a solution increases from 2 to 4.
It was first noted by  that WN18 and FB15k suffer from test leakage through inverse relations: a large number of test triples can be obtained simply by inverting triples in the training set. For example, the test set frequently contains triples such as (s, hyponym, o) while the training set contains its inverse (o, hypernym, s). To create a dataset without this property, Toutanova and Chen (2015) introduced FB15k-237 -a subset of FB15k where inverse relations are removed. However, they did not explicitly investigate the severity of this problem, which might explain why research continues using these datasets for evaluation without addressing this issue (e.g., Nickel, Rosasco, and Poggio (2016),,).
In the following section, we introduce a simple rule-based model which demonstrates the severity of this bias by achieving state-of-the-art results on both WN18 and FB15k. In order to ensure that we evaluate on datasets that do not have inverse relation test leakage, we apply our simple rule-based model to each dataset. Apart from FB15k, which was corrected by FB15k-237, we also find flaws with WN18. We thus create WN18RR to reclaim WN18 as a dataset, which cannot easily be completed using a single rule -but requires modelling of the complete knowledge graph. WN18RR 1 contains 93,003 triples with 40,943 entities and 11 relations. For future research, we recommend against using FB15k and WN18 and instead recommend FB15k-237, WN18RR, and YAGO3-10.
section: Experimental Setup
We selected the hyperparameters of our ConvE model via grid search according to the mean reciprocal rank (MRR) on the validation set. Hyperparameter ranges for the grid search were as follows -embedding dropout {0.0, 0.1, 0.2}, feature map dropout {0.0, 0.1, 0.2, 0.3}, projection layer dropout {0.0, 0.1, 0.3, 0.5}, embedding size {100, 200}, batch size {64, 128, 256}, learning rate {0.001, 0.003}, and label smoothing {0.0, 0.1, 0.2, 0.3}.
Besides the grid search, we investigated modifications of the 2D convolution layer for our models. In particular, we experimented with replacing it with fully connected layers and 1D convolution; however, these modifications consistently reduced the predictive accuracy of the model. We also experimented with different filter sizes, and found that we only receive good results if the first convolutional layer uses small (i.e. 3x3) filters. We found that the following combination of parameters works well on WN18, YAGO3-10 and FB15k: embedding dropout 0.2, feature map dropout 0.2, projection layer dropout 0.3, embedding size 200, batch size 128, learning rate 0.001, and label smoothing 0.1. For the Countries dataset, we increase embedding dropout to 0.3, hidden dropout to 0.5, and set label smoothing to 0. We use early stopping according to the mean reciprocal rank (WN18, FB15k, YAGO3-10) and AUC-PR (Countries) statistics on the validation set, which we evaluate every three epochs. Unlike the other datasets, for Countries the results have a high variance, as such we average 10 runs and produce 95% confidence intervals. For our DistMult and ComplEx results with 1-1 training, we use an embedding size of 100, AdaGrad (Duchi, Hazan, and Singer 2011) for optimisation, and we regularise our model by forcing the entity embeddings to have a L2 norm of 1 after each parameter update. As in, we use a pairwise margin-based ranking loss.
The code for our model and experiments is made publicly available, 2 as well as the code for replicating the DistMult results.
section: Inverse Model
It has been noted by , that the training datasets of WN18 and FB15k have 94% and 81% test leakage as inverse relations, that is, 94% and 81% of the triples in these datasets have inverse relations which are linked to the test set. For instance, a test triple (feline, hyponym, cat) can easily be mapped to a training triple (cat, hypernym, feline) if it is known that hyponym is the inverse of hypernym. This is highly problematic, because link predictors that do well on these datasets may simply learn which relations that are the inverse of others, rather than to model the actual knowledge graph.
To gauge the severity of this problem, we construct a simple, rule-based model that solely models inverse relations. We call this model the inverse model. The model extracts inverse relationships automatically from the training set: given two relation pairs r 1 , r 2 ∈ R, we check whether (s, r 1 , o) implies (o, r 2 , s), or vice-versa.
We assume that inverse relations are randomly distributed among the training, validation and test sets and, as such, we expect the number of inverse relations to be proportional to the size of the training set compared to the total dataset size. Thus, we detect inverse relations if the presence of (s, r 1 , o) co-occurs with the presence of (o, r 2 , s) with a frequency of at least 0.99 − (f v + ft ), where f v and ft is the fraction of the validation and test set compared to the total size of the dataset. Relations matching this criterion are assumed to be the inverse of each other.
At test time, we check if the test triple has inverse matches outside the test set: if k matches are found, we sample a permutation of the top k ranks for these matches; if no match is found, we select a random rank for the test triple.
section: Results
Similarly to previous work (; Niepert 2016), we report results using a filtered setting, i.e. we rank test triples against all other candidate triples not appearing in the training, validation, or test set (). Candidates are obtained by permuting either the subject or the object of a test triple with all entities in the knowledge graph. Our results on the standard benchmarks FB15k and WN18 are shown in; results on the datasets with inverse relations removed are shown in; results on YAGO3-10 and Countries are shown in.
Strikingly, the inverse model achieves state-of-the-art on many different metrics for both FB15k and WN18. However, it fails to pickup on inverse relations for YAGO3-10 and FB15k-237. The procedure used by  to derive FB15k-237 does not remove certain symmetric relationships, for example "similar to". The presence of these relationships explains the good score of our inverse model on WN18RR, which was derived using the same procedure.
Our proposed model, ConvE, achieves state-of-the-art performance for all metrics on YAGO3-10, for some metrics on FB15k, and it does well on WN18. On Countries, it solves the S1 and S2 tasks, and does well on S3, scoring better than other models like DistMult and ComplEx.
For FB15k-237, we could not replicate the basic model results from , where the models in general have better performance than what we can achieve. Compared to, our results for standard models area slightly better then theirs, and on-a-par with their R-GCN model.
section: Parameter efficiency of ConvE
From we can see that ConvE for FB15k-237 with 0.23M parameters performs better than DistMult with 1.89M parameters for 3 metrics out of 5.
ConvE with 0.46M parameters still achieves state-of-theart results on FB15k-237 with 0.425 Hits@10. Comparing to  the previous best model, R-GCN (), which achieves 0.417 Hits@10 with more than 8M parameters. Overall, ConvE is more than 17x parameter efficient than R-GCNs, and 8x more parameter efficient than DistMult. For the entirety of Freebase, the size of these models would be more than 82GB for R-GCNs, 21GB for DistMult, compared to 5.2GB for ConvE.
section: Analysis
Ablation Study shows the results from our ablation study where we evaluate different parameter initialisation (n = 2) to calculate confidence intervals. We see that hidden dropout is by far the most important component, which is unsurprising since it is our main regularisation technique. 1-N scoring improves performance, as does input dropout, feature map dropout has a minor effect, while label smoothing seems to be unimportant -as good results can be achieved without it.
section: Analysis of Indegree and PageRank
Our main hypothesis for the good performance of our model on datasets like YAGO3-10 and FB15k-237 compared to WN18RR, is that these datasets contain nodes with very high relation-specific indegree. For example the node "United States" with edges "was born in" has an indegree of over 10,000. Many of these 10,000 nodes will be very different from each other (actors, writers, academics, politicians, business people) and successful modelling of such a high indegree nodes requires capturing all these differences. Our hypothesis is that deeper models, that is, models that learn multiple layers of features, like ConvE, have an advantage over shallow models, like DistMult, to capture all these constraints.
However, deeper models are more difficult to optimise, so we hypothesise that for datasets with low average relationspecific indegree (like WN18RR and WN18), a shallow model like DistMult might suffice for accurately representing the structure of the network.
To test our two hypotheses, we take two datasets with low (low-WN18) and high (high-FB15k) relation-specific indegree and reverse them into high (high-WN18) and low (lowFB15k) relation-specific indegree datasets by deleting low and high indegree nodes. We hypothesise that, compared to DistMult, ConvE will always do better on the dataset with high relation-specific indegree, and vice-versa.
Indeed, we find that both hypotheses hold: for low-FB15k we have ConvE 0.586 Hits@10 vs DistMult 0.728 Hits@10; for high-WN18 we have ConvE 0.952 Hits@10 vs DistMult 0.938 Hits@10. This supports our hypothesis that deeper models such as ConvE have an advantage to model more complex graphs (e.g. FB15k and FB15k-237), but that shallow models such as DistMult have an advantage to model less complex graphs (e.g. WN18 WN18RR).
To investigate this further, we look at PageRank, a measure of centrality of anode. PageRank can also be seen as a measure of the recursive indegree of a node: the PageRank value of anode is proportional to the indegree of this node, its  1.711 0.00 Countries S2
1.796 17.6: Ablation study for FB15k-237.
section: Ablation Hits@10
Full ConvE 0.491
Hidden dropout -0.044 ± 0.003 Input dropout -0.022 ± 0.000 1-N scoring -0.019 Feature map dropout -0.013 ± 0.001 Label smoothing -0.008 ± 0.000 neighbours indegrees, its neighbours-neighbours indegrees and so forth scaled relative to all other nodes in the network. By this line of reasoning, we also expect ConvE to be better than DistMult on datasets with high average PageRank (high connectivity graphs), and vice-versa.
To test this hypothesis, we calculate the PageRank for each dataset as a measure of centrality. We find that the most central nodes in WN18 have a PageRank value more than one order of magnitude smaller than the most central nodes in YAGO3-10 and Countries, and about 4 times smaller than the most central nodes in FB15k. When we look at the mean PageRank of nodes contained in the test sets, we find that the difference of performance in terms of Hits@10 between DistMult and ConvE is roughly proportional to the mean test set PageRank, that is, the higher the mean PageRank of the test set nodes the better ConvE does compared to DistMult, and vice-versa. See for these statistics. The correlation between mean test set PageRank and relative error reduction of ConvE compared to DistMult is strong with r = 0.56. This gives additional evidence that models that are deeper have an advantage when modelling nodes with high (recursive) indegree.
From this evidence we conclude, that the increased performance of our model compared to a standard link predictor, DistMult, can be partially explained due to our it's ability to model nodes with high indegree with greater precisionwhich is possibly related to its depth.
section: Conclusion and Future Work
We introduced ConvE, a link prediction model that uses 2D convolution over embeddings and multiple layers of nonlinear features to model knowledge graphs. ConvE uses fewer parameters; it is fast through 1-N scoring; it is expressive through multiple layers of non-linear features; it is robust to overfitting due to batch normalisation and dropout; and achieves state-of-the-art results on several datasets, while still scaling to large knowledge graphs. In our analysis, we show that the performance of ConvE compared to a common link predictor, DistMult, can partially be explained by its ability to model nodes with high (recursive) indegree.
Test leakage through inverse relations of WN18 and FB15k was first reported by : we investigate the severity of this problem for commonly used datasets by introducing a simple rule-based model, and find that it can achieve state-of-the-art results on WN18 and FB15k. To ensure robust versions of all investigated datasets exists, we derive WN18RR.
Our model is still shallow compared to convolutional architecture found in computer vision, and future work might deal with convolutional models of increasing depth. Further work might also look at the interpretation of 2D convolution, or how to enforce large-scale structure in embedding space so to increase the number of interactions between embeddings. • 2018-04-06: Victoria Lin helped us to find and fix issues with triple masks during evaluation. We report new numbers for UMLS and Nations in the appendix. The results were unchanged on other datasets that we tested thus far (Kinship, WN18, WN18RR, FB15k-237).
section: SUPPLEMENTAL MATERIAL
• 2018-03-28:
-New numbers for Inverse Model after bugfix by Takuma Ebisu. -New numbers for UMLS/Nations/Kinship datasets in appendix using the most commonly reported test data splits.
• 2018-01-07: Extended AAAI camera ready (6/7/8).
• 2017-07-08: Missing grant in acknowledgements.
• 2017-07-05: Original NIPS submission (6/7/6).
section: Further ConvE results
section: Evaluation Metrics
We now describe the evaluation metrics used for assessing the quality of the models. Let T = {x 1 , x 2 , . . . , x |T | } denote See https://github.com/TimDettmers/ConvE/ issues/26 for details. See https://github.com/TimDettmers/ConvE/ issues/18 for more information. the test set. Following, for the i-th test triplex i in T , we generate all its possible corruptions C s (x i ) (resp. Co (x i )) -obtained by replacing its subject (resp. object) with any other entity in the Knowledge Graph -to check whether the model assigns an higher score to xi and a lower score to its corruptions. Note that the set of corruptions can also contain several true triples, and it is not a mistake to rank them with an higher score than xi . For such a reason, we remove all triples in the graph from the set of corruptions: this is referred to as the filtered setting in. The left and right rank of the i-th test tripleeach associated to corrupting either the subject or the objectaccording to a model with scoring function ψ( · ), are defined as follows: MRR is the average inverse rank for all test triples: the higher, the better. Hits@k is the percentage of ranks lower than or equal to k: the higher, the better.
