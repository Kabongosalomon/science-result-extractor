section: title
Approaching Neural Grammatical Error Correction as a Low-Resource Machine Translation Task
section: abstract
Previously, neural methods in grammatical error correction (GEC) did not reach state-of-the-art results compared to phrase-based statistical machine translation (SMT) baselines. We demonstrate parallels between neural GEC and low-resource neural MT and successfully adapt several methods from low-resource MT to neural GEC. We further establish guidelines for trustable results in neural GEC and propose a set of model-independent methods for neural GEC that can be easily applied inmost GEC settings. Proposed methods include adding source-side noise, domain-adaptation techniques, a GEC-specific training-objective, transfer learning with monolingual data, and ensembling of independently trained GEC models and language models. The combined effects of these methods result in better than state-of-the-art neural GEC models that out-perform previously best neural GEC systems by more than 10% M 2 on the CoNLL-2014 benchmark and 5.9% on the JFLEG test set. Non-neural state-of-the-art systems are outper-formed by more than 2% on the CoNLL-2014 benchmark and by 4% on JFLEG.
section: Introduction
Most successful approaches to automated grammatical error correction (GEC) are based on methods from statistical machine translation (SMT), especially the phrase-based variant. For the CoNLL 2014 benchmark on grammatical error correction ( ), Junczys-Dowmunt and Grundkiewicz (2016) established a set of methods for GEC by SMT that remain state-of-the-art. Systems) that improve on results by use their set-up as a backbone for more complex systems.
The view that GEC can be approached as a machine translation problem by translating from erroneous to correct text originates from and resulted in many systems (e.g.) that represented the current state-of-the-art at the time.
In the field of machine translation proper, the emergence of neural sequence-to-sequence methods and their impressive results have lead to a paradigm shift away from phrase-based SMT towards neural machine translation (NMT).) authors of pure phrase-based systems offered "unconditional surrender" 1 to NMT-based methods.
Based on these developments, one would expect to see arise of state-of-the-art neural methods for GEC, but as Junczys-Dowmunt and Grundkiewicz (2016) already noted, this is not the case. Interestingly, even today, the top systems on established GEC benchmarks are still mostly phrase-based or hybrid systems). The best "pure" neural systems () are several percent behind. If we look at recent MT work with this in mind, we find one area where phrased-based SMT dominates over NMT: low-resource machine translation. analyze the behavior of NMT versus SMT for English-Spanish systems trained on 0.4 million to 385.7 million words of parallel data, illustrated in. Quality for NMT  starts low for small corpora, outperforms SMT at a corpus size of about 15 million words, and with increasing size beats SMT with a large in-domain language model. lists existing training resources for the English as-a-second-language (ESL) grammatical error correction task. Publicly available resources, NUS Corpus of Learner English (NUCLE) by, Lang-8 NAIST () and CLC FCE) amount to about 27M tokens. Among these the Lang-8 corpus is quite noisy and of low quality. The Cambridge Learner Corpus (CLC) by -probably the best resource in this listis non-public and we would strongly discourage reporting results that include it as training data as this makes comparisons difficult.
Contrasting this with, we see that for about 20M tokens NMT systems start outperforming SMT models without additional large language models. Current state-of-the-art GEC systems based on SMT, however, all include large-scale indomain language models either following the steps outlined in Junczys- or directly re-using their domain-adapted Common-Crawl language model. It seems that the current state of neural methods in GEC reflects the behavior for NMT systems trained on smaller data sets. Based on this, we conclude that we can think of GEC as a lowresource, or at most mid-resource, machine translation problem. This means that techniques proposed for low-resource (neural) MT should be applicable to improving neural GEC results.
In this work we show that adapting techniques from low-resource (neural) MT and SMT-based GEC methods allows neural GEC systems to catch up to and outperform SMT-based systems. We improve over the previously best-reported neural GEC system () on the CoNLL 2014 test set by more than 10% M 2 , over a comparable pure SMT system by Junczys-Dowmunt and Grundkiewicz (2016) by 6%, and outperform the state-of-the-art result of by 2%. On the JFLEG data set, we report the currently best results, outperforming the previously best pure neural system ( ) by 5.9% GLEU and the best reported results) by 3% GLEU.
In Section 2, we describe our NMT-based baseline for GEC, and follow recommendations from the MT community fora trustable neural GEC system. In Section 3, we adapt neural models to make better use of sparse error-annotated data, transferring low-resource MT and GEC-specific SMT methods to neural GEC. This includes a novel training objective for GEC. We investigate how to leverage monolingual data for neural GEC by transfer learning in Section 4 and experiment with language model ensembling in Section 5. Section 6 explores deep NMT architectures. In Section 7, we provide an overview of the experiments and how results relate to the JFLEG benchmark. We also recommend a model-independent toolbox for neural GEC.
section: A trustable baseline for neural GEC
In this section, we combine insights from JunczysDowmunt and Grundkiewicz (2016) for grammatical error correction by phrase-based statistical machine translation and from for trustable results in neural machine translation to propose a trustable baseline for neural grammatical error correction.
section: Training and test data
To make our results comparable to state-of-the-art results in the field of GEC, we limit our training data strictly to public resources. In the case of error-annotated data, as marked in and. We strongly urge the community to not use the non-public CLC corpus for training, unless contrastive results without this corpus are provided as well.
We choose the CoNLL-2014 shared task test set ( ) as our main benchmark and the test set from the 2013 edition of the shared task ( ) as a development set. For these benchmarks we report MaxMatch (M 2 ) scores. Where appropriate, we will provide results on the JFLEG dev and test sets ( ) using the GLEU metric () to demonstrate the generality of our methods. summarizes test/dev set statistics for both tasks.
For most our experiments, we report M 2 on CoNLL-2013 test (Dev) and precision (Prec.), recall (Rec.), M 2 (Test) on the CoNLL-2014 test set.
section: Preprocessing and sub-words
As both benchmarks, CoNLL and JFLEG, are provided in NLTK-style tokenization (, we use the same tokenization scheme for our training data. We truecase line beginnings and escape special characters using scripts included with Moses (. Following , we apply the Enchant 3 spell-checker to the JFLEG data before evaluation. No spellchecking is used for the CoNLL test sets.
We follow the recommendation by to use byte-pair encoding (BPE) sub-word units) to solve the large-vocabulary problem of NMT. This is a well established procedure in neural machine translation and has been demonstrated to be generally superior to UNK-replacement methods. It has been largely ignored in the field of grammatical error correction even when word segmentation issues have been explored (). To our knowledge, this is the first work to use BPE sub-words for GEC, however, an analysis on advantages of word versus sub-word or character level segmentation is beyond the scope of this paper. A set of 50,000 monolingual BPE units is trained on the error-annotated data and we segment training and test/dev data accordingly. Segmentation is reversed before evaluation.
section: Model and training procedure
Implementations of all models explored in this work are available in the Marian 5 toolkit). The attentional encoderdecoder model in Marian is a re-implementation of the NMT model in Nematus (). The model differs from the model introduced by by several aspects, the most important being the conditional GRU with attention for which Sennrich et al. (2017b) provide a concise description.
All embedding vectors consist of 512 units; the RNN states of 1024 units. The number of BPE segments determines the size of the vocabulary of our models, i.e. 50,000 entries. Source and target side use the same vocabulary. To avoid overfitting, we use variational dropout ( over GRU steps and input embeddings with probability 0.2. We optimize with Adam () with an average mini-batch size of ca. 200. All models are trained until convergence (early-stopping with a patience of 10 based on development set cross-entropy cost), saving model checkpoints every 10,000 mini-batches. The best eight model checkpoints w.r.t. the development set M 2 score of each training run are averaged elementwise
section: Optimizer instability
Junczys-Dowmunt and Grundkiewicz  Neural sequence-to-sequence training is discriminative optimization and as such prone to instability. We already try to alleviate this by averaging over eight best checkpoints, but as seen in, results for M 2 remain unstable for runs with differently initialized weights. An amplitude of 3 points M 2 on the CoNLL-2014 test set is larger than most improvements reported in recent papers. None of the recent works on neural GEC account for instability, hence it is unclear if observed outcomes are actual improvements or lucky picks among byproducts of instability. We therefore strongly suggest to provide results for multiple independently trained models. Otherwise improvements of less than 2 or 3 points of M 2 remain doubtful. Interestingly, GLEU on the JFLEG data seems to be more stable than M 2 on CoNLL data.
section: Ensembling of independent models
Running multiple experiments to provide averaged results seems prohibitively expensive, but and others (e.g. show that ensembling of independently trained models leads to consistent rewards for MT. For our baseline in the opposite seems to be true for M 2 . This is likely the reason why no other work on neural GEC mentions results for ensembles.   On closer inspection, however, we see that the drop in M 2 for ensembles is due to a precision bias. M 2 being an F-score penalizes increasing distance between precision and recall. The increase in precision for ensembles is to be expected and we see it later consistently for all experiments. Ensembles choose corrections for which all independent models are fairly confident. This leads to fewer but better corrections, hence an increase in precision and a drop in recall. If the models are weak as our baseline, this can result in a lower score. It would, however, be unwise to dismiss ensembles, as we can use their bias towards precision to our advantage whenever they are combined with methods that aim to increase recall. This is true for nearly all remaining experiments.
section: Source-word dropout as corruption
GEC can be treated as a denoising task where grammatical errors are corruptions that have to be reduced. By introducing more corruption on the source side during training we can teach the model to reduce trust into the source input and to apply corrections more freely. Dropout is one way to introduce noise, but for now we only dropout single units in the embedding or GRU layers, something the model can easily recover from. To make the task harder, we add dropout over source words, setting the full embedding vector fora source word to 1/p src with a probability of p src . During our experiments, we found p src = 0.2 to work best. show impressive gains for this simple method (+Dropout-Src.). Results for the ensemble match the previously best results on the CoNLL-2014 test set for pure neural systems (without the use of an additional monolingual language model) by and.
section: Domain adaptation
The NUCLE corpus matches the domain of the CoNLL benchmarks perfectly. It is however much smaller than the Lang-8 corpus. A setting like this seems to be a good fit for domain-adaptation techniques. oversample in-domain news data in a larger non-news training corpus. We do the same by adding the NU-CLE corpus ten times to the training corpus. This can also be seen as similar to Junczys-Dowmunt and Grundkiewicz (2016) who tune phrase-based SMT parameters on the entire NUCLE corpus. Respectable improvements on both CoNLL test sets (+Domain-Adapt. in) are achieved.
section: Error adaptation
Junczys-Dowmunt and Grundkiewicz (2016) noticed that when tuning on the entire NUCLE corpus, even better results can be achieved if the error rate of NUCLE is adapted to the error rate of the original dev set. In NUCLE only 6% of tokens contain errors, while the CoNLL-2013 test set has an error-rate of about 15%. Following JunczysDowmunt and Grundkiewicz (2016), we remove correct sentences from the ten-fold oversampled NUCLE data greedily until an error-rate of 15% is achieved. This can be interpreted as a type of GEC-specific domain adaptation. We mark this method as +Domain-Adapt. in and report for the ensemble the so far strongest results for any neural GEC system on the CoNLL benchmark.
CoNLL JFLEG Λ Dev Prec. Rec. Test Dev Test 1 33.5 67.5 20.8 46.6 48.9 53.9 3 36.8 59.8 28.8 49.2 51.2 56.5 5 36.2 54.0 30.8 47.0 50.9 55.7: Results for model type +Tied-Emb. trained with edit-weighted MLE and chosen Λ.
section: Tied embeddings
Press and Wolf showed that parameter tying between input and output embeddings 7 for language models leads to improved perplexity. Similarly, three-way weight-tying between source, target and output embeddings for neural machine translation seems to improve translation quality in terms of BLEU while also significantly decreasing the number of parameters in the model. In monolingual cases like GEC, where source and target vocabularies are (mostly) equal, embedding-tying seems to arise naturally. Output layer, decoder and encoder embeddings all share information which may further enhance the signal from corrective edits. The M 2 scores for +Tied-Emb. in are inconclusive, but we see improvements in conjunction with later modifications.
section: Edit-weighted MLE objective
Previously, we applied error-rate adaptation to strengthen the signal from corrective edits in the training data. In this section, we investigate the effects of directly modifying the training loss to incorporate weights for corrective edits.
Assuming that each target token y j has been generated by a source token xi , we scale the loss for each target token y j by a factor Λ if y j differs from xi , i.e. if y j is part of an edit. Hence, loglikelihood loss takes the following form:
λ(x at , y t ) log P (y t |x, y <t ),
where (x, y) is a training sentence pair and a is a word alignment at ∈ {0, 1, . . . , T x } such that source token x at generates target token y t . Alignments are computed for each sentence pair with fast-align (. Pre-trained embeddings Pre-trained decoder parameters Randomly initialized parameters This is comparable to reinforcement learning towards GLEU as introduced by  or training against diffs by. In combination with previous modifications, edit-weighted Maximum Likelihood Estimation (MLE) weighting seem to outperform both methods. The parameter Λ introduces an additional hyper-parameter that requires tuning for specific tasks and affects the precision/recall trade-off. Table 5 shows Λ = 3 seems to work best among the tested values when chosen to maximize M 2 on the CoNLL-2013 dev set.
For this setting, we achieve our strongest results of 50.95 M 2 on the CoNLL benchmark (system +Edit-MLE) yet. This outperforms the results of a phrase-based SMT system with a large domainadapted language model from Junczys-Dowmunt and Grundkiewicz (2016) by 1% M 2 and is the first neural system to beat this strong SMT baseline.
section: Transfer learning for GEC
Many ideas in low-resource neural MT are rooted in transfer learning. In general, one first trains a neural model on high-resource data and then uses the resulting parameters to initialize parameters of anew model meant to be trained on lowresource data only. Various settings are possible, e.g. initializing from models trained on large outof-domain data and continuing on in-domain data ) or using related language pairs (. Models can also be partially initialized by pre-training monolingual language models ( or only word-embeddings (. In GEC, apply pretrained monolingual word-embeddings as initializations for error-detection models to re-rank SMT n-best lists. Approaches based on pre-training with monolingual data appear to be particularly wellsuited to the GEC task. Junczys-Dowmunt and Grundkiewicz (2016) published 300GB of compressed monolingual data used in their work to create a large domain-adapted Common-Crawl ngram language model. We use the first 100M lines. Preprocessing follows section 2.2 including BPE segmentation.
section: Pre-training embeddings
Similarly to or, we use Word2vec () with standard settings to create word vectors. Since weights between source, target and output embeddings are tied, these embeddings are inserted once into the model, but affect computations three-fold, seethe blue elements in. The remaining parameters of the model are initialized randomly. We refer to this adaptation as +Pretrain-Emb.
section: Pre-training decoder parameters
Following, we first train a GRU-based language model on the monolingual data. The architecture of the language model corresponds as much as possible to the structure of the decoder of the sequence-to-sequence model. All pieces that rely on the attention mechanism or the encoder have been removed. After training for two epochs, all red parameters (including embedding layers) in are copied from the language model to the decoder. Remaining parameters are initialized randomly. This configuration is called +Pretrain-Dec. We pretrain each model separately to make sure that all weights have been initialized randomly.: Ensembling with a neural language model.
section: Results for transfer learning
(2017) fora much more complex system and outperforms the highest neural GEC system (Ji et al., 2017) by 8% M 2 .
section: Ensembling with language models
Phrase-based SMT systems benefit naturally from large monolingual language models, also in the case of GEC as shown by Junczys-Dowmunt and Grundkiewicz re-use the language model provided by Junczys-Dowmunt and Grundkiewicz (2016) for n-best list re-ranking. We already combined monolingual data with our GEC models via pre-training, but exploiting separate language models is attractive as no additional training is required. Here, we reuse the neural language model created for pre-training.
Similarly to, the score s(y|x) fora correction y of sentence x is calculated as
, where P i (y|x) is a translation probability for the i-th model in an ensemble of 4. P LM (y) is the language model probability for y weighted by α.
We normalize by sentence length |y|. Using the dev set, we choose α that maximizes this score via linear search in range with step 0.1. summarizes results for language model ensembling with three of our intermediate configurations. All configurations benefit from the language model in the ensemble, although gains for the pre-trained model are rather small.
section: Deeper NMT models
So far we analyzed model-independent 9 methods -only training data, hyper-parameters, parameter initialization, and the objective function were modified. In this section we investigate if these techniques can be generalized to deeper or different architectures.
section: Architectures
We consider two state-of-the-art NMT architectures implemented in Marian: Transformer The self-attention-based model by. We base our model on their default architecture of 6 complex attention/selfattention blocks in the encoder and decoder and use the same model dimensions -embeddings vector size is 512 (as before), filter size is 2048.
section: Training settings
As the deep models are less reliably trained with asynchronous SGD, we change the training algorithm to synchronous SGD and for both models follow the recipe proposed in, with an effective base learning rate of 0.0003, learning rate warm-up during the first 16,000 iterations, and an inverse square-root decay after the warmup. As before, we average the best 8 checkpoints. We increase dropout probability over RNN layers to 0.3 for Deep-RNN and similarly set dropout between transformer layers to 0.3. Source-word dropout as a noising technique remains unchanged.
section: Model
Dev: Shallow (Pretrain-Dec.) versus deep ensembles, with and without corresponding language models.
section: Pre-training deep models
We reuse all methods included up to +Pretrain-Dec. The pre-training procedure as described in section 4.1 needs to be modified in order to maximize the number of pre-trained parameters for the larger model architectures. Again, we train decoder-only models as typical language models by removing all elements that depend on the encoder, including attention-mechanisms over the source context. We can keep the decoder self-attention layers in the transformer model. We train for two epochs on our monolingual data reusing the hyper-parameters for the parallel case above. summarizes the results for deeper models on the CoNLL dev and test set. Both deep models improve significantly over the shallow model with the transformer model reaching our best result reported on the CoNLL 2014 test set. For that test set it seems that ensembling with language models that were used for pre-training is ineffective when measured with M 2 ; while on the JFLEG data measured with GLEU we see strong improvements.
section: Results
section: A standard tool set for neural GEC
We summarize the results for our experiments in and provide results on the JFLEG test set. Weights for the independent language model in the full ensemble were chosen on the respective dev sets for both tasks. Comparing results according to both benchmarks and evaluation metrics (M 2 for CoNLL, GLEU for JFLEG), it seems we can isolate the following set of reliable methods for state-ofthe-art neural grammatical error correction:
• Ensembling neural GEC models with monolingual language models;
• Dropping out entire source embeddings;   • Weighting edits in the training objective during optimization (+Edit-MLE);
• Pre-training on monolingual data;
• Ensembling of independently trained models;
• Domain and error adaptation (+Domain-Adapt., Error-Adapt.) towards a specific benchmark;
• Increasing model depth.
Combinations of these generally 10 modelindependent methods helped raising the performance of pure neural GEC systems by more than 10% M 2 on the CoNLL 2014 benchmark, also outperforming the previous state-of-the-art), a hybrid phrase-based system with a complex spell-checking system by 2%. We also showed that a pure neural system can easily outperform a strong pure phrase-based SMT system when similarly adapted to the GEC task.
On the JFLEG benchmark we outperform the previously-best pure neural system ( ) by 5.9% GLEU (4.5% if no monolingual data is used). Improvements over SMT-based system like and Chollampatt and Ng (2017) are significant and constitute the new state-of-the-art on the JFLEG test set.
