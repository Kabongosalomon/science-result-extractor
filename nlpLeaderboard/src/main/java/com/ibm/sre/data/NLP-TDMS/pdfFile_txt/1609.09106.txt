section: title
HYPERNETWORKS
section: abstract
This work explores hypernetworks: an approach of using a one network, also known as a hypernetwork, to generate the weights for another network. Hypernet-works provide an abstraction that is similar to what is found in nature: the relationship between a genotype-the hypernetwork-and a phenotype-the main network. Though they are also reminiscent of HyperNEAT in evolution, our hyper-networks are trained end-to-end with backpropagation and thus are usually faster. The focus of this work is to make hypernetworks useful for deep convolutional networks and long recurrent networks, where hypernetworks can be viewed as relaxed form of weight-sharing across layers. Our main result is that hypernetworks can generate non-shared weights for LSTM and achieve near state-of-the-art results on a variety of sequence modelling tasks including character-level language modelling, handwriting generation and neural machine translation, challenging the weight-sharing paradigm for recurrent networks. Our results also show that hypernetworks applied to convolutional networks still achieve respectable results for image recognition tasks compared to state-of-the-art baseline models while requiring fewer learnable parameters.
section: INTRODUCTION
In this work, we consider an approach of using a small network (called a "hypernetwork") to generate the weights fora larger network (called a main network). The behavior of the main network is the same with any usual neural network: it learns to map some raw inputs to their desired targets; whereas the hypernetwork takes a set of inputs that contain information about the structure of the weights and generates the weight for that layer (see).: A hypernetwork generates the weights fora feedforward network. Black connections and parameters are associated the main network whereas orange connections and parameters are associated with the hypernetwork.
HyperNEAT () is an example of hypernetworks where the inputs area set of virtual coordinates for each weight in the main network. In this work, we will focus on a more powerful approach where the input is an embedding vector that describes the entire weights of a given layer. Our embedding vectors can be fixed parameters that are also learned during end-to-end training, allowing approximate weight-sharing within a layer and across layers of the main network. In addition, our embedding vectors can also be generated dynamically by our hypernetwork, allowing the weights of a recurrent network to changeover timesteps and also adapt to the input sequence.
We perform experiments to investigate the behaviors of hypernetworks in a range of contexts and find that hypernetworks mix well with other techniques such as batch normalization and layer normalization. Our main result is that hypernetworks can generate non-shared weights for LSTM that work better than the standard version of LSTM). On language modelling tasks with Character Penn Treebank, Hutter Prize Wikipedia datasets, hypernetworks for LSTM achieve near state-of-the-art results. On a handwriting generation task with IAM handwriting dataset, Hypernetworks for LSTM achieves high quantitative and qualitative results. On image classification with CIFAR-10, hypernetworks, when being used to generate weights fora deep convnet (, obtain respectable results compared to state-of-the-art models while having fewer learnable parameters. In addition to simple tasks, we show that Hypernetworks for LSTM offers an increase in performance for large, production-level neural machine translation models.
section: MOTIVATION AND RELATED WORK
Our approach is inspired by methods in evolutionary computing, where it is difficult to directly operate in large search spaces consisting of millions of weight parameters. A more efficient method is to evolve a smaller network to generate the structure of weights fora larger network, so that the search is constrained within the much smaller weight space. An instance of this approach is the work on the HyperNEAT framework (). In the HyperNEAT framework, Compositional Pattern-Producing Networks (CPPNs) are evolved to define the weight structure of much larger main network. Closely related to our approach is a simplified variation of HyperNEAT, where the structure is fixed and the weights are evolved through Discrete Cosine Transform (DCT) is called Compressed Weight Search (. Even more closely related to our approach are Differentiable Pattern Producing Networks (DPPNs), where the structure is evolved but the weights are learned, and ACDC-Networks ( , where linear layers are compressed with DCT and the parameters are learned.
Most reported results using these methods, however, are in small scales, perhaps because they are both slow to train and require heuristics to be efficient. The main difference between our approach and HyperNEAT is that hypernetworks in our approach are trained end-to-end with gradient descent together with the main network, and therefore are more efficient.
In addition to end-to-end learning with gradient descent, our approach strikes a good balance between Compressed Weight Search and HyperNEAT in terms of model flexibility and training simplicity. First, it can be argued that Discrete Cosine Transform used in Compressed Weight Search maybe too simple and using the DCT prior may not be suitable for many problems. Second, even though HyperNEAT is more flexible, evolving both the architecture and the weights in HyperNEAT is often an overkill for most practical problems.
Even before the work on HyperNEAT and DCT, has suggested the concept of fast weights in which one network can produce context-dependent weight changes fora second network. Small scale experiments were conducted to demonstrate fast weights for feed forward networks at the time, but perhaps due to the lack of modern computational tools, the recurrent network version was mentioned mainly as a thought experiment. A subsequent work demonstrated practical applications of fast weights, where a generator network is learnt through evolution to solve an artificial control problem. The concept of a network interacting with another network is central to the work of (, and especially, where certain parameters in a convolutional network are predicted by another network. These studies however did not explore the use of this approach to recurrent networks, which is a main contribution of our work.
The focus of this work is to generate weights for practical architectures, such as convolutional networks and recurrent networks by taking layer embedding vectors as inputs. However, our hypernetworks can also be utilized to generate weights fora fully connected network by taking coordinate information as inputs similar to DPPNs. Using this setting, hypernetworks can approximately re-cover the convolutional architecture without explicitly being told to do so, a similar result obtained by "Convolution by Evolution"). This result is described in Appendix A.1.
section: METHODS
In this paper, we view convolutional networks and recurrent networks as two ends of a spectrum. On one end, recurrent networks can be seen as imposing weight-sharing across layers, which makes them inflexible and difficult to learn due to vanishing gradient. On the other end, convolutional networks enjoy the flexibility of not having weight-sharing, at the expense of having redundant parameters when the networks are deep. Hypernetworks can be seen as a form of relaxed weightsharing, and therefore strikes a balance between the two ends. See Appendix A.2 for conceptual diagrams of Static and Dynamic Hypernetworks.
section: STATIC HYPERNETWORK: A WEIGHT FACTORIZATION APPROACH FOR DEEP CONVOLUTIONAL NETWORKS
First we will describe how we construct a hypernetwork for the purpose of generating the weights of a feedforward convolutional network. Ina typical deep convolutional network, the majority of model parameters are in the kernels of convolutional layers. Each kernel contain N in × N out filters and each filter has dimensions f size × f size . Let's suppose that these parameters are stored in a matrix K j ∈ R Ninfsize×Noutfsize for each layer j = 1, .., D, where Dis the depth of the main convolutional network. For each layer j, the hypernetwork receives a layer embedding z j ∈ R Nz as input and predicts K j , which can be generally written as follows:
We note that this matrix K j can be broken down as N in slices of a smaller matrix with dimensions f size ×N out f size , each slice of the kernel is denoted as K j i ∈ R fsize×Noutfsize . Therefore, in our approach, the hypernetwork is a two-layer linear network. The first layer of the hypernetwork takes the input vector z j and linearly projects it into the N in inputs, with N in different matrices W i ∈ R d×Nz and bias vectors Bi ∈ Rd , where dis the size of the hidden layer in the hypernetwork. For our purpose, we fix d to be equal to N z although they can be different. The final layer of the hypernetwork is a linear operation which takes an input vector a i of size d and linearly projects that into K i using a common tensor W out ∈ R fsize×Noutfsize×d and bias matrix B out ∈ R fsize×Noutfsize . The final kernel K j will be a concatenation of every K j i . Thus g(z j ) can be written as follows:
In our formulation, the learnable parameters are W i , Bi , W out , B out together with all z j 's. During inference, the model simply takes the layer embeddings z j learned during training to reproduce the kernel weights for layer j in the main convolutional network. As aside effect, the number of learnable parameters in hypernetwork will be much lower than the main convolutional network. In fact, the total number of learnable parameters in hypernetwork is
parameters for the kernels of the main convolutional network.
Our approach of constructing g(.) is similar to the hierarchically semiseparable matrix approach proposed by. Note that even though it seems redundant to have a two-layered linear hypernetwork as that is equivalent to a one-layered hypernetwork, the fact that W out and B out are shared makes our two-layered hypernetwork more compact than a one-layered hypernetwork. More concretely, a one-layered hypernetwork would have N z × N in × f size × N out × f size learnable parameters which is usually much bigger than a two-layered hypernetwork does.
The above formulation assumes that the network architecture consists of kernels with same dimensions. In practice, deep convolutional network architectures consists of kernels of varying dimensions. Typically, in many designs, the kernel dimensions are integer multiples of a basic size. This is indeed the casein the residual network family of architectures () that we will be experimenting with later is an example of such a design. In our experiments, although the kernels of a residual network do not share the same dimensions, the Ni and N out dimensions for each kernel are integer multiples of 16. To modify our approach to work with this architecture, we have our hypernetwork generate kernels for this basic size of 16, and if we require a larger kernel fora certain layer, we will concatenate multiple basic kernels together to form the larger kernel.
For example, if we need to generate a kernel with Ni = 32 and N out = 64, we will tile eight basic kernels together. Each basic kernel is generated by a unique z embedding, hence the larger kernel will be expressed with eight embeddings. Therefore, kernels that are larger in size will require a proportionally larger number of embedding vectors. For visualizations of concatenated kernels, please see Appendix A.2.1. shows the similarity between kernels learned by a ConvNet to classify MNIST digits and those learned by a hypernetwork generating weights fora ConvNet.
section: DYNAMIC HYPERNETWORK: ADAPTIVE WEIGHT GENERATION FOR RECURRENT NETWORKS
In the previous section, we outlined a procedure for using a hypernetwork to generate the weights fora deep convolutional network. In this section, we will use a recurrent network to dynamically generate weights for another recurrent network, such that the weights can vary across many timesteps. In this context, hypernetworks are called dynamic hypernetworks, and can be seen as a form of relaxed weight-sharing, a compromise between hard weight-sharing of traditional recurrent networks, and no weight-sharing of convolutional networks. This relaxed weight-sharing approach allows us to control the trade off between the number of model parameters and model expressiveness.
Our dynamic hypernetworks can be used to generate weights for RNN and LSTM. When a hypernetwork is used to generate the weights for an RNN, it is called HyperRNN. At every time step t, a HyperRNN takes as input the concatenated vector of input x t and the hidden states of the main RNN h t−1 , it then generates as output the vectorˆhvectorˆ vectorˆh t . This vector is then used to generate the weights for the main RNN at the same timestep. Both the HyperRNN and the main RNN are trained jointly with backpropagation and gradient descent. In the following, we will give a more formal description of the model.
The standard formulation of a Basic RNN is given by:
where ht is the hidden state, φ is a non-linear operation such as tanh or relu, and the weight matrices and bias In HyperRNN, we allow W hand W x to float overtime by using a smaller hypernetwork to generate these parameters of the main RNN at each step (see). More concretely, the parameters W h , W x , b of the main RNN are different at different time steps, so that ht can now be computed as:
, where
Where
We use a recurrent hypernetwork to compute z h , z x and z b as a function of x t and h t−1 :
Where
As the embeddings z h , z x and z bare of dimensions N z , which is typically smaller than the hidden state size N ˆ h of the HyperRNN cell, a linear network is used to project the output of the HyperRNN cell into the embeddings in Equation 6. After the embeddings are computed, they will be used to generate the full weight matrix of the main RNN.
The above is a general formulation of a linear dynamic hypernetwork applied to RNNs. However, we found that in practice, Equation 5 is often not practical because the memory usage becomes too large for real problems. The amount of memory required in the system described in Equation 5 will be N z times the memory of a Basic RNN, which limits the number of hidden units we can use in many practical applications.
We can modify the dynamic hypernetwork system described in Equation 5 so that it can be much more scalable and memory efficient. Our approach borrows from the static hypernetwork section and we will use an intermediate hidden vector d(z) ∈ RN h to parametrize a weight matrix, where d(z) will be a linear projection of z. To dynamically modify a weight matrix W , we will allow each row of this weight matrix to be scaled linearly by an element in vector d. We refer d as a weight scaling vector. Below is the modification to W (z):
While we sacrifice the ability to construct an entire weight matrix from a linear combination of N z matrices of the same size, we are able to linearly scale the rows of a single matrix with N z degrees of freedom. We find this to be a good trade off, as this formulation of converting W (z) into W (d(z)) decreases the amount of memory required by the dynamic hypernetwork. Rather than requiring N z times the memory of a Basic RNN, we will only be using memory in the order N z times the number of hidden units, which is an acceptable amount of extra memory usage that is often available in many applications. In addition, the row-level operation in Equation 7 can be shown to be equivalent to an element-wise multiplication operator and hence computationally much more efficient in practice.
Below is the more memory efficient version of the setup of Equation 5:
, where Since the HyperRNN cell can indirectly modify the rows of each weight matrix and also the bias of the main RNN, it is implicitly also performing a linear scaling to the inputs of the activation function.
The difference here is that the linear scaling parameters can be different for each timestep and also for for each input sample. It will be interesting to compare the scaling policy that the HyperRNN cell comes up with, to the hand engineered statistical-moments based scaling approaches. In addition, we note that the existing normalization approaches can work together with the HyperRNN approach, where the HyperRNN cell will be tasked with discovering a better dynamical scaling policy to complement normalization. We will also explore this combination in our experiments.
The Long Short-Term Memory (LSTM) architecture) is usually better than the Basic RNN at storing and retrieving information over longer time steps. In our experiments, we will focus on this LSTM version of the HyperRNN, called the HyperLSTM. The details of the HyperLSTM architecture is described in Appendix A.2.2, along with specific implementation details in Appendix A.2.3. We want to know whether the HyperLSTM cell can learn a weight adjustment policy that can rival statistical moments-based normalization methods, hence Layer Normalization will be one of our baseline methods. We will therefore conduct experiments on two versions of HyperLSTM, one with and one without the application of Layer Normalization.
section: EXPERIMENTS
In the following experiments, we will benchmark the performance of static hypernetworks on image recognition with MNIST and CIFAR-10, and the performance of dynamic hypernetworks on language modelling with Penn Treebank and Hutter Prize Wikipedia (enwik8) datasets and handwriting generation.
section: USING STATIC HYPERNETWORKS TO GENERATE FILTERS FOR CONVOLUTIONAL NETWORKS AND MNIST
We start by applying a hypernetwork to generate the filters fora convolutional network on MNIST.
Our main convolutional network is a small two layer network and the hypernetwork is used to generate the kernel for the second layer (7x7x16x16), which contains the bulk of the trainable parameters in the system. Our weight matrix will be summarized by an embedding of size N z = 4. See Appendix A.3.1 for further experimental setup details.
For this task, the hypernetwork achieved a test accuracy of 99.24%, comparable to the 99.28% for the conventional method. In this example, a kernel consisting of 12,544 weights is represented by an embedding vector of only 4 parameters, generated by a hypernetwork that has 4240 parameters. We can seethe weight matrix this network produced by the hypernetwork in. Now the question is whether we can also train a deep convolutional network, using a single hypernetwork generating a set of weights for each layer, on a dataset more challenging than MNIST.
section: STATIC HYPERNETWORKS FOR RESIDUAL NETWORK ARCHITECTURE AND CIFAR-10
The residual network architectures ( are popular for image recognition tasks, as they can accommodate very deep networks while maintaining effective gradient flow across layers using skip connections. The original resnet and subsequent derivatives () achieved state-of-the-art image recognition performance on a variety of public datasets. While residual networks can be be very deep, and in some experiments as deep as 1001 layers, it is important to understand whether some these layers share common properties and can be reduced effectively by introducing weight sharing. If we enforce weight-sharing across many layers of a deep feed forward network, the network may share many properties to that of a recurrent network. In this experiment, we want to explore this idea of enforcing relaxed weight sharing across all of the layers of a deep residual network. We will take a simple version of residual network, use a single hypernetwork to generate the weights of all of its layers for image classification task on the CIFAR-10 dataset.
group name output size block type conv1
32. N determines the number of residual blocks in each group. Network width is determined by factor k. Our experiment will use aversion of the wide residual network, described in, a popular and simple variant of the family of residual network architectures, and we will focus configurations (N = 6, K = 1) and (N = 6, K = 2), referred to as WRN 40-1 and WRN 40-2 respectively. In this setup, we will use a hypernetwork to generate all of the kernels in conv2, conv3, and conv4, so we will generate 36 layers of kernels in total. The WRN architecture uses a filter size of 3 for every kernel. We use the method outlined in the Methods section to deal with kernels of varying sizes, and use the an embedding size of N z = 64 in our experiments. See Appendix A.3.2 for further experimental setup details.
We obtained similar classification accuracy numbers as reported in with our own implementation. We also note that the weights generated by the hypernetwork are used in a batch normalization setting without modification to the original model. In principle, hypernetworks can also be applied to the newer variants of residual networks with more skip connections, such as DenseNets and ResNets of Resnets.
From the results, we see that enforcing a relaxed weight sharing constraint to the deep residual network cost us ∼ 1.25-1.5% in classification accuracy, while drastically reducing the number of  parameters in the model as a trade off. One reason for this reduction inaccuracy is because different layers of a deep network is trained to extract different levels of features, and require different kinds of filters to perform optimally. The hypernetwork enforces some commonality between every layer, but offers each layer 64 degrees of freedom to distinguish itself from the other layers. While the network is no longer able to learn the optimal set of filters for each layer, it will learn the best set of filters given the constraints, and the resulting number of model parameters is drastically reduced.
section: HYPERLSTM FOR CHARACTER-LEVEL PENN TREEBANK LANGUAGE MODELLING
The HyperLSTM model is evaluated on character level prediction task on the Penn Treebank corpus () using the train/validation/test split outlined in (. As the dataset is quite small is prone to over fitting, we apply dropout on both input and output layers with a keep probability of 0.90. Unlike previous approaches) of applying weight noise during training, we instead also apply dropout to the recurrent layer () with the same dropout probability.
We compare our model to the basic LSTM cell, stacked LSTM cells, and LSTM with layer normalization applied. In addition, we also experimented with applying layer normalization to HyperLSTM. Using the setup in, we use networks with 1000 units and train the network to predict the next character. for the loss graphs.  When we use this prediction model as a generative model to sample a text passage, we use main RNN to model a probability distribution over possible characters conditioned over the preceding characters. In the case of the HyperRNN, we allow the model parameters of this generative model to vary overtime, so in effect the HyperRNN cell is choosing the best model at any given time to generate a probability distribution to sample from. We can demonstrate this by visualizing how the weight scaling vectors of the main RNN change during the character sampling process. In, we examine a sample text passage generated by HyperLSTM after training on enwik8 along with the weight differences below the text. We see that in regions of low intensity, where the weights of the main RNN are relatively static, the types of phrases generated seem more deterministic. For example, the weights do not change much during the words Europeans, possessions and reservation. The regions of high intensity is when the HyperRNN cell is making relatively large changes to the weights of the main RNN. These tend to happen in the areas between words, or sometimes during brackets.
One might also wonder whether the HyperLSTM cell (without Layer Norm), via dynamically tuning the weight scaling vectors, has developed a policy that is similar to the statistics-based approach used by Layer Norm, given that both methods have similar performance. One way to see this effect is to look at the histogram of the hidden states in the network. In, we examine the histograms of φ(c t ), the hidden state of the LSTM before applying the output gate. We see that the normalization process employed by Layer Norm reduces the saturation effects compared to the vanilla LSTM. However, for the case of the HyperLSTM, we notice that most of the time the cell is saturated. The HyperLSTM cell's dynamic weight adjustment policy appears to be doing something very different compared to statistical normalization, although the policy it came up with ended up providing similar performance as Layer Norm. It is interesting to see that when we combine both methods, the HyperLSTM cell will need to determine an adjustment policy in spite of the normalization forced upon it by Layer Norm. An interesting question is whether there are problems where statistical normalization may actually be a setback to the policy developed by the HyperLSTM, and the best strategy is to ignore it.
section: HYPERLSTM FOR HANDWRITING SEQUENCE GENERATION
In addition to modelling discrete sequential data, we want to see how the model performs when modelling sequences of real valued data. We will train our model on the IAM online handwriting database) and have our model predict pen strokes as per Section 4.2 of (Graves, 2013). The dataset has contains 12179 handwritten lines from 221 writers, digitally recorded from a tablet. We will model the (x, y) coordinate of the pen location at each recorded time step, along with a binary indicator of pen-up/pen-down. The average sequence length is around 700 steps and the longest around 1900 steps, making the training task particularly challenging as the network needs to retain information about both the stroke history and also the handwriting style in order to predict plausible future handwriting strokes. For experimental setup details, please refer to Appendix A.3.5.
section: Model
Log: Log-Loss of IAM Online DB validation set.
In this task, we note that data augmentation and applying recurrent dropout improved the performance of all models, compared to the original setup by. In addition, for the LSTM model, increasing unit count per layer may not help the performance compared to increasing the layer depth. We notice that a 3-layer 400 unit LSTM outperforms a 1-layer 900 unit one, and we found that a 2-layer 650 unit LSTM outperforming most configurations. While layer norm helps with the performance, we found that in this task, layer norm does not combine well with HyperL-STM, and in this task the 900 unit HyperLSTM without layer norm achieved the best performance. Unlike the language modelling task, perhaps statistical normalization is far from the optimal approach fora weight adjustment policy. The policy learned by the HyperLSTM cell not only per-formed well against the baseline, its convergence rate is also as fast as the 2-layer LSTM model. Please refer to for the loss graphs.
In Appendix A.5, we display three sets of handwriting samples generated from LSTM, Layer Norm LSTM, and HyperLSTM, corresponding to log-loss scores of -1055, -1096, and -1162 nats respectively in. Qualitative assessments of handwriting quality is always subjective, and depends an individual's taste in calligraphy. From looking at the examples produced by the three models, our opinion is that the samples produced by LSTM is noisier than the other two models. We also find HyperLSTM's samples to be a bit more coherent than the samples produced by Layer Norm LSTM. We leave to the reader to judge which model produces handwriting samples of higher quality. We see that the regions of high intensity seem to be concentrated at many discrete instances, rather than slowly varying overtime. This implies that the weights experience regime changes rather than gradual slow adjustments. We can see that many of these weight changes occur between the written words, and sometimes between written characters. While the LSTM model alone already does a formidable job of generating time-varying parameters of a Mixture Gaussian distribution used to generate realistic handwriting samples, the ability to go one level deeper, and to dynamically generate the generative model is one of the key advantages of HyperRNN over a normal RNN.
section: HYPERLSTM FOR NEURAL MACHINE TRANSLATION
We experiment with the Neural Machine Translation task using the same experimental setup outlined in ( . Our model is the same wordpiece model architecture with a vocabulary size of 32k, but we replace the LSTM cells with HyperLSTM cells. We benchmark the modified model on WMT'14 En→Fr using the same test/validation set split described in the GNMT paper ( . Please refer to Appendix A.3.6 for experimental setup details.
section: Model
Test  The HyperLSTM cell improves the performance of the existing GNMT model, achieving stateof-the-art single model results for this dataset. In addition, we demonstrate the applicability of hypernetworks to large-scale models used in production systems. Please see Appendix A.6 for actual translation samples generated from both models fora qualitative comparison.
section: CONCLUSION
In this paper, we presented a method to use a hypernetwork to generate weights for another neural network. Our hypernetworks are trained end-to-end with backpropagation and therefore are efficient and scalable. We focused on two use cases of hypernetworks: static hypernetworks to generate weights fora convolutional network, dynamic hypernetworks to generate weights for recurrent networks. We found that the method works well while using fewer parameters. On image recognition, language modelling and handwriting generation, hypernetworks are competitive to or sometimes better than state-of-the-art models. We ran an experiment where the hypernetwork receives the x, y locations of both the input pixel and the weight, and predicts the value of the hidden weight matrix in a fully connected network that learns to classify MNIST digits. In this experiment, the fully connected network (784-256-10) has one hidden layer of 16 × 16 units, where the hypernetwork is a pre-defined small feedforward network. The weights of the hidden layer has 784 × 256 = 200704 parameters, while the hypernetwork is a 801 parameter four layer feed forward relu network that would generate the 786 × 256 weight matrix. The result of this experiment is shown in. We want to emphasize that even though the network can learn convolutional-like filters during end-to-end training, its performance is rather poor: the best accuracy is 93.5%, compared to 98.5% for the conventional fully connected network.
section: A APPENDIX
We find that the virtual coordinates-based approach to hypernetworks that is used by HyperNEAT and DPPN has its limitations in many practical tasks, such as image recognition and language modelling, and therefore developed our embedding vector approach in this work.
section: A.2 CONCEPTUAL DIAGRAMS OF STATIC AND DYNAMIC HYPERNETWORKS
section: A.2.2 HYPERLSTM
In this section we will discuss extension of HyperRNN to LSTM. Our focus will be on the basic version of the LSTM architecture, given by:
where
is the sigmoid operator, φ is the tanh operator. For brevity, y is one of {i, g, f, o}. 1 Similar to the previous section, we will make the weights and biases a function of an embedding, and the embedding for each {i, g, f, o} will be generated from a smaller HyperLSTM cell. As discussed earlier, we will also experiment with adding the option to use a Layer Normalization layer in the HyperLSTM. The HyperLSTM Cell is given by:
The weight matrices for each of the four {i, g, f, o} gates will be a function of a set of embeddings z x , z h , and z b unique to each gates, just like the HyperRNN. These embeddings are linear projections of the hidden states of the HyperLSTM Cell. For brevity, y is one of {i, g, f, o} to avoid writing four sets of identical equations:
As in the memory efficient version of the HyperRNN, we will focus on the efficient version of the HyperLSTM, where we use weight scaling vectors d to modify the rows of the weight matrices:
, where
In our implementation, the cell and hidden state update equations for the main LSTM will incorporate a single dropout () gate, as developed in Recurrent Dropout without Memory Loss (), as we found this to help regularize the entire model during training:
This dropout operation is generally only applied inside the main LSTM, not in the smaller HyperL-STM cell. For larger size systems we can apply dropout to both networks.
section: A.2.3 IMPLEMENTATION DETAILS AND WEIGHT INITIALIZATION FOR HYPERLSTM
This section maybe useful to readers who may want to implement their own version of the Hyper-LSTM Cell, as we will discuss initialization of the parameters for Equations 10 to 13. We recommend implementing the HyperLSTM within the same interface as a normal recurrent network cell so that using the HyperLSTM will not be any different than using a normal RNN. These initialization parameters have been found to work well with our experiments, but they maybe far from optimal depending on the task at hand. A reference implementation developed using the Tensor- The embedding vectors are produced by the HyperLSTM Cell at each timestep by linear projection described in Equation 11. The weights for the first two equations are initialized to be zero, and the biases are initialized to one. The weights for the third equation are initialized to be a small normal random variable with standard deviation of 0.01.
The weight scaling vectors that modify the weight matrices are generated from these embedding vectors, as per Equation 12. Orthogonal initialization is applied to the W hand W x , while b 0 is initialized to zero. W bz is also initialized to zero. For the weight scaling vectors, we used a method described in Recurrent Batch Normalization () where the scaling vectors are initialized to 0.1 rather than 1.0 and this has shown to help gradient flow. Therefore, for weight matrices W hz and W xz , we initialize to a constant value of 0.1/N z to maintain this property.
The only place we use dropout is in the single location in Equation 13, developed in Recurrent Dropout without Memory Loss (). We can use this dropout gate like any other normal dropout gate in a feed-forward network.
section: A.3 EXPERIMENT SETUP DETAILS AND HYPER PARAMETERS
section: A.3.1 USING STATIC HYPERNETWORKS TO GENERATE FILTERS FOR CONVOLUTIONAL NETWORKS AND MNIST
We train the network with a 55000 / 5000 / 10000 split for the training, validation and test sets and use the 5000 validation samples for early stopping, and train the network using Adam) with a learning rate of 0.001 on mini-batches of size 1000. To decrease over fitting, we pad MNIST training images to 30x30 pixels and random crop to 28x28. 1
section: Model Test Error Params of 2 nd Kernel
Normal Convnet 0.72% 12,544 Hyper Convnet 0.76% 4,244 We train both the normal residual network and the hypernetwork version using a 45000 / 5000 / 10000 split for training, validation, and test set. The 5000 validation samples are randomly chosen and isolated from the original 50000 training samples. We train the entire setup with a mini-batch size of 128 using Nesterov Momentum SGD for the normal version and Adam for the hypernetwork version, both with a learning rate schedule. We apply L2 regularization on the kernel weights, and also on the hypernetwork-generated kernel weights of 0.0005%. To decrease over fitting, we apply light data augmentation pad training images to 36x36 pixels and random crop to 32x32, and perform random horizontal flips.
section: A.3.3 CHARACTER-LEVEL PENN TREEBANK
The hyper-parameters of all the experiments were selected through non-extensive grid search on the validation set. Whenever possible, we used reported learning rates and batch sizes in the literature that had been used for similar experiments performed in the past.
For Character-level Penn Treebank, we use mini-batches of size 128, to train on sequences of length 100. We trained the model using Adam) with a learning rate of 0.001 and gradient clipping of 1.0. During evaluation, we generate the entire sequence, and do not use information about previous test errors for prediction, e.g., dynamic evaluation. As mentioned earlier, we apply dropout to the input and output layers, and also apply recurrent dropout with a keep probability of 90%. For baseline models, Orthogonal Initialization ( is performed for all weights.
We also experimented with aversion of the model using a larger embedding size of 16, and also with a lower dropout keep probability of 85%, and reported results with this "Large Embedding" model in. Lastly, we stacked two layers of this "Large Embedding" model together to measure the benefits of a multi-layer version of HyperLSTM, with a dropout keep probability of 80%.
section: A.3.4 HUTTER PRIZE WIKIPEDIA
As enwik8 is a bigger dataset compared to Penn Treebank, we will use 1800 units for our networks. In addition, we perform training on sequences of length 250. Our normal HyperLSTM Cell consists of 256 units, and we use an embedding size of 64.
Our setup is similar in the previous experiment, using the same mini-batch size, learning rate, weight initialization, gradient clipping parameters and optimizer. We do not use dropout for the input and output layers, but still apply recurrent dropout with a keep probability of 90%. For baseline models, Orthogonal Initialization () is performed for all weights.
As in (, we train on the first 90M characters of the dataset, use the next 5M as a validation set for early stopping, and the last 5M characters as the test set.
In this experiment, we also experimented with a slightly larger version of HyperLSTM with 2048 hidden units. This version of of the model uses 2048 hidden units for the main network, inline with similar models for this experiment in other works. In addition, its HyperLSTM Cell consists of 512 units with an embedding size of 64. Given the larger number of nodes in both the main LSTM and HyperLSTM cell, recurrent dropout is also applied to the HyperLSTM Cell of this model, where we use a lower dropout keep probability of 85%, and train on an increased sequence length of 300.
section: A.3.5 HANDWRITING SEQUENCE GENERATION
We will use the same model architecture described in and use a Mixture Density Network layer to generate a mixture of bi-variate Gaussian distributions to model at each time step to model the pen location. We normalize the data and use the same train/validation split as per) in this experiment. We remove samples less than length 300 as we found these samples contain a lot of recording errors and noise. After the pre-processing, as the dataset is small, we introduce data augmentation of chosen uniformly from +/-10% and apply a this random scaling a the samples used for training.
One concern we want to address is the lack of a test set in the data split methodology devised in. In this task, qualitative assessment of generated handwriting samples is arguably just as important as the quantitative log likelihood score of the results. Due to the small size of the dataset, we want to use as large as possible the portion of the dataset to train our models in order to generate better quality handwriting samples so we can also judge our models qualitatively in addition to just examining the log-loss numbers, so for this task we will use the same training / validation split as, with a caveat that we maybe somewhat over fitting to the validation set in the quantitative results. In future works, we will explore using larger datasets to conduct a more rigorous quantitative analysis.
For model training, will apply recurrent dropout and also dropout to the output layer with a keep probability of 0.95. The model is trained on mini-batches of size 32 containing sequences of variable length. We trained the model using Adam) with a learning rate of 0. The GNMT paper outlines several methods for the training procedure, and investigated several approaches including combining Adam and SGD optimization methods, in addition to weight quantization schemes. In our experiment, we used only the Adam) optimizer with the same hyperparameters described in the GNMT paper. We did not employ any quantization schemes.
We replaced LSTM cells in the GNMT WPM-32K architecture, with LayerNorm HyperLSTM cells with the same number of hidden units. In this experiment, our HyperLSTM Cell consists of 128 units with an embedding size of 32.  ), but its claim is that it holds the size of the coci, but is historically important both for import: brewing and commercial use.
section: A.4 EXAMPLES OF GENERATED WIKIPEDIA TEXT
A majority of cuisine specifically refers to this period, where the southern countries developed in the 19th century. Scotland had a cultural identity of or now a key church who worked between the 8th and 60th through 6 (so that there are small single authors of detailed recommendations for them and at first) rather than appearing ,  We randomly selected translation samples generated from both LSTM baseline and HyperLSTM models from the WMT'14 En→Fr Test Set. Given an English phrase, we can compare between the correct French translation, the LSTM translation, and the HyperLSTM translation.
section: English Input
I was expecting to see gnashing of teeth and a fight breaking out at the gate .
section: French (Ground Truth)
Je m' attendais à voir des grincements de dents et une bagarre éclater à la porte .
section: LSTM Translation
Je m' attendais à voir des larmes de dents et un combat à la porte .
section: HyperLSTM Translation
Je m' attendais à voir des dents grincer des dents et une bataille éclater à la porte .
section: English Input
Prosecuting , Anne Whyte said : " If anyone should know not to the break the law , it is a criminal solicitor . " French (Ground Truth)
Le procureur Anne Whyte a déclaré : « Si quelqu' un doit savoir qu' il ne faut pas violer la loi , c' est bien un avocat pénaliste . »
section: LSTM Translation
Prosecuting , Anne Whyte a dit : « Si quelqu' un doit savoir qu' il ne faut pas enfreindre la loi , c' est un solicitor criminel .
section: HyperLSTM Translation
En poursuivant , Anne Whyte a dit : « Si quelqu' un doit savoir ne pas enfreindre la loi , c' est un avocat criminel .
section: English Input
According to her , the CSRS was invited to a mediation and she asked for an additional period for consideration . French (Ground Truth)
Selon elle , la CSRS a été invitée à une médiation et elle a demandé un délai supplémentaire pour y réfléchir .
section: LSTM Translation
Selon elle , le SCRS a été invité à une médiation et elle a demandé un délai supplémentaire .
section: HyperLSTM Translation
Selon elle , le SCRS a été invité à une médiation et elle a demandé une période de réflexion supplémentaire .
section: English Input
Relations between the US and Germany have come under strain following claims that the NSA bugged Chancellor Angela 's Merkel 's phone .
section: French (Ground Truth)
Les relations entre les États-Unis et l' Allemagne ont été mises à rude épreuve à la suite de plaintes selon lesquelles la NSA avait mis sur écoute le téléphone portable de la chancelière allemande Angela Merkel .
section: LSTM Translation
Les relations entre les Etats-Unis et l' Allemagne ont été mises à rude épreuve suite aux affirmations selon lesquelles la NSA aurait pris le téléphone de Merkel de la chancelière Angela .
section: HyperLSTM Translation
Les relations entre les États-Unis et l' Allemagne ont été mises à rude épreuve après que la NSA a attaqué le téléphone de la chancelière Angela Angela .
section: English Input
Germany 's BfV advises executives to consider using simple prepaid mobiles when on foreign trips because of the risk that smart phones are compromised .
section: LSTM Translation
Le BfV allemand conseille aux dirigeants d' envisager l' utilisation de mobiles prépayés simples lors de voyages à l' étranger en raison du risque de compromission des téléphones intelligents .
section: HyperLSTM Translation
Le BfV allemand conseille aux dirigeants d' envisager l' utilisation de téléphones mobiles prépayés simples lors de voyages à l' étranger en raison du risque que les téléphones intelligents soient compromis .
section: English Input
I was on the mid-evening news that same evening , and on TV the following day as well . French (Ground Truth)
Le soir-même , je suis au 20h , le lendemain aussi je suis à la télé .
section: LSTM Translation
J' étais au milieu de l' actualité le soir même , et à la télévision le lendemain également .
section: HyperLSTM Translation
J' étais au milieu de la soirée ce soir-là et à la télévision le lendemain .
