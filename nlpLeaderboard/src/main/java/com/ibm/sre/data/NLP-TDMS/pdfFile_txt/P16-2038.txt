section: title
Deep multi-task learning with low level tasks supervised at lower layers
section: abstract
In all previous work on deep multi-task learning we are aware of, all task super-visions are on the same (outermost) layer. We present a multi-task learning architecture with deep bi-directional RNNs, where different tasks supervision can happen at different layers. We present experiments in syntactic chunking and CCG supertag-ging, coupled with the additional task of POS-tagging. We show that it is consistently better to have POS supervision at the innermost rather than the outermost layer. We argue that this is because "low-level" tasks are better kept at the lower layers, enabling the higher-level tasks to make use of the shared representation of the lower-level tasks. Finally, we also show how this architecture can be used for domain adaptation.
section: Introduction
We experiment with a multi-task learning (MTL) architecture based on deep bi-directional recurrent neural networks (bi-RNNs)). MTL can be seen as away of regularizing model induction by sharing representations (hidden layers) with other inductions. We use deep bi-RNNs with task supervision from multiple tasks, sharing one or more bi-RNNs layers among the tasks. Our main contribution is the novel insight that (what has historically been thought of as) low-level tasks are better modeled in the low layers of such an architecture. This is in contrast to previous work on deep MTL , in which supervision for all tasks happen at the same (outermost) layer. Multiple-tasks supervision at the outermost layer has a strong tradition in neural net models in vision and elsewhere). However, in NLP it is natural to think of some levels of analysis as feeding into others, typically with low-level tasks feeding into highlevel ones; e.g., POS tags as features for syntactic chunking) or parsing (. Our architecture can be seen as a seamless way to combine multi-task and cascaded learning. We also show how the proposed architecture can be applied to domain adaptation, in a scenario in which we have high-level task supervision in the source domain, and lower-level task supervision in the target domain.
As a point of comparison, Collobert et al. (2011) improved deep convolutional neural network models of syntactic chunking by also having task supervision from POS tagging at the outermost level. In our work, we use recurrent instead of convolutional networks, but our main contribution is observing that we obtain better performance by having POS task supervision at a lower layer. While Collobert et al. (2011) also experiment with NER and SRL, they only obtain improvements from MTL with POS and syntactic chunking. We show that similar gains can be obtained for CCG supertagging.
Our contributions (i) We present a MTL architecture for sequence tagging with deep bi-RNNs; (ii) We show that having task supervision from all tasks at the outermost level is often suboptimal; (iii) we show that this architecture can be used for domain adaptation.
section: Sequence tagging with deep bi-RNNs
Notation We use x 1:n to denote a sequence of n vectors x 1 , · · · , x n . F θ (·) is a function parameterized with parameters θ. We write FL (·) as a shortcut to F θ L -an instantiation of F with a spe-cific set of parameters θ L . We use • to denote a vector concatenation operation.
Deep bi-RNNs We use a specific flavor of Recurrent Neural Networks (RNNs) called long short-term memory networks (LSTMs)). For brevity, we treat RNNs as a black-box abstraction, and LSTMs as an instance of the RNN interface. For further details on RNNs and LSTMs, see. We view RNN as a parameterized function RN N θ (x 1:n ) mapping a sequence of n input vectors x 1:n , xi ∈ Rd in to a an output vector h n ∈ R dout . The output vector h n is conditioned on all the input vectors x 1:n , and can bethought of as a summary of x 1:n . The RNN can be applied to all prefixes x 1:i , 1 ≤ i ≤ n of x 1:n , resulting inn output vectors h 1:n , where h 1:i summarizes x 1:i .
A deep RNN (or k-layer RNN) is composed of k RNN functions RN N 1 , · · · , RN N k that feed into each other: the output h 1:n of RN N becomes the input of RN N +1 . Stacking RNNs in this way was empirically shown to be effective.
A bidirectional RNN) is composed of two RNNs, RN NF and RN NR , one reading the sequence in its regular order, and the other reading it in reverse. Concretely, given a sequence x 1:n and a desired index i, the function BIRN N θ (x 1:n , i) is defined as:
The vector vi = BIRN N (x 1:n , i) is then a representation of the ith item in x 1:n , taking into account both the entire history x 1:i and the entire future x i:n .
Finally, in a deep bidirectional RNN, both RN NF and RN NR are k-layer RNNs, and
. Greedy sequence tagging with deep bi-RNNs Ina sequence tagging task, we are given an input w 1 , · · · , w n and need to predict an output
where L is a label set of interest; i.e., in a POS tagging task, L is the part-of-speech tagset, and y i is the pos-tag for word w i .
If we take the inputs x 1:n to correspond to a sequence of sentence words w 1 , · · · , w n , we can think of vi = BIRN N (x 1:n , i) as inducing an infinite window around a focus word w i . We can then use vi as an input to a multiclass classification function f (v i ), to assign a tagˆytagˆ tagˆy i to each input location i. The tagger is greedy: the tagging decisions are independent of each other. However, as shown below and in other recent work using bi-RNNs for sequence tagging, we can still produce competitive tagging accuracies, because of the richness of the representation vi that takes the entire input sequence into account.
For a k-layer bi-RNN tagger we get:
where E as an embedding function mapping each word in the vocabulary into ad emb -dimensional vector, and v k i is the output of the kth BIRNN layer as defined above.
All the parameters (the embedding vectors for the different vocabulary items, the parameters of the different RNNs and the parameters of the classification function f ) are trained jointly in order to minimize the tagging loss over a sentence. The embedding vectors are often initialized using vectors that were pre-trained in a semi-supervised manner.
This sequence tagging architecture was introduced to NLP by. A similar architecture (with an RNN instead of bi-RNN) was applied to CCG supertagging by.
MTL in deep bi-RNNs Ina multi-task learning (MTL) setting, we have several prediction tasks over the same input space. For example, in sequence tagging, the input maybe the words in the sentence, and the different tasks can be POS-tagging, named entity recognition, syntactic chunking, or CCG supertagging. Note that the different tasks do not have to be traditional NLP tasks, but also, say, two POS-annotated corpora with slightly different guidelines. Each task has its own output vocabulary (a task specific tagset), but all of them map the length n input sequence into a length n output sequence.
Intuitively, although NLP tasks such as POS tagging, syntactic chunking and CCG supertagging are different than each other, they also share lot of substructure, e.g., knowing that a word is a verb can help in determining its CCG supertag and the syntactic chunk it participate in. We would therefore like for these models to share parameters.
The common approach is to share parameters across most of the network. In the k-layers deep bi-RNN tagger described above this is naturally achieved by sharing the bi-RNN part of the network across tasks, but training a specialized classification tagger ft (v k i ) for each task t. This encourages the deep bi-RNN to learn a representation v k i that is useful for prediction of the different tasks, allowing them to share parameters.
section: Supervising different tasks on different layers
Previous work in NLP on cascaded learning such as suggests there is sometimes a natural order among the different tasks: some tasks may benefit more from other tasks, than the other way around. This suggests having task supervision for low-level tasks at the lower bi-RNN layers. This also enables task-specific deep learning of the high-level tasks.
Instead of conditioning all tasks on the outermost bi-RNN layer, we associate an RNN level (t) with each task t, and let the task specific classifier feed from that layer, e.g., pos tag(w 1:n , i) = f pos (v ). This enables a hierarchy a task with cascaded predictions, as well as deep task-specific learning for high-level tasks. This means there will be layers shared by all tasks and layers that are specific to some tasks:
The Multi-task training protocol We assume T different training set, D 1 , · · · , D T , where each D t contains pairs of input-output sequences (w 1:n , y t 1:n ), w i ∈ V , y ti ∈ Lt . The input vocabulary V is shared across tasks, but the output vocabularies (tagset) Lt are task dependent.
At each step in the training process we choose a random task t, followed by a random training instance (w 1:n , y t 1:n ) ∈ D t . We use the tagger to predict the labelsˆylabelsˆ labelsˆy ti , suffer a loss with respect to the true labels y ti and update the model parameters. Notice that a task t is associated with a bi-RNN level (t). The update fora sample from task t affects the parameters off t and BIRN N 1 , · · · , BIRN N (t) , but not the parameters off t =t or BIRN N j>>(t) .
Implementation details Our implementation is based the CNN library 1 for dynamic neural networks. We use CNN's LSTM implementation as our RNN variant. The classifiers ft () take the form of a linear transformation followed by a softmax ft (v) = arg maxi sof tmax(W (t) v+b t ), where the weights matrix W (t) and bias vector b (t) are task-specific parameters. We use a cross-entropy loss summed over the entire sentence. The network is trained using back-propagation and SGD with batch-sizes of size 1, with the default learning rate. Development data is used to determine the number of iterations.
We initialize the embedding layer E with pretrained word embeddings. We use the Senna embeddings 2 in our domain adaptation experiments, but these embeddings may have been induced from data including the test data of our main experiments, so we use the Polyglot embeddings in these experiments. We use the same dimensionality for the hidden layers as in our pre-trained embeddings.
section: Experiments and Results
We experiment with POS-tagging, syntactic chunking and CCG supertagging. See examples of the different tasks below:
In-domain MTL In these experiments, POS, Chunking and CCG data are from the English Penn Treebank. We use sections 0-18 for training POS and CCG supertagging, 15-18 for training chunking, 19 for development, 20 for evaluating chunking, and 23 for evaluating CCG supertagging. These splits were motivated by the need for comparability with previous results.   We do MTL training for either (POS+chunking) or (POS+CCG), with POS being the lower-level task. We experiment three architectures: single task training for higher-level tasks (no POS layer), MTL with both tasks feeding off of the outer layer, and MTL where POS feeds off of the inner (1st) layer and the higher-level task on the outer Our CHUNKS results are competitive with stateof-the-art., for example, reported an F 1 -score of 95.15% on the CHUNKS data. Our model also performs considerably better than the MTL model in. Note that our relative improvements are also bigger than those reported by. Our CCG super tagging results are also slighly better than a recently reported result in (93.00%). Our results are significantly better (p < 0.05) than our baseline, and POS supervision at the lower layer is consistently better than standard MTL.
section: LAYERS
section: DOMAINS CHUNKS POS BROADCAST (6) BC-NEWS (8) MAGAZINES
Additional tasks? We also experimented with NER (CoNLL 2003), super senses (SemCor), and the Streusle Corpus of texts annotated with MWE brackets and super sense tags. In none of these cases, MTL led to improvements. This suggests that MTL only works when tasks are sufficiently similar, e.g., all of syntactic nature. Collobert et al. (2011) also observed a drop in NER performance and insignificant improvements for SRL. We believe this is an important observation, since previous work on deep MTL often suggests that most tasks benefit from each other.
Domain adaptation We experiment with domain adaptation for syntactic chunking, based on OntoNotes 4.0. We use WSJ newswire as our source domain, and broadcast, broadcasted news, magazines, and weblogs as target domains. We assume main task (syntactic chunking) supervision for the source domain, and lower-level POS supervision for the target domains. The results in indicate that the method is effective for domain adaptation when we have POS supervision for the target domain. We believe this result is worth exploring further, as the scenario in which we have target-domain training data for low-level tasks such as POS tagging, but not for the task we are interested in, is common. The method is effective only when the lower-level POS supervision is applied at the lower layer, supporting the importance of supervising different tasks at different layers.
Rademacher complexity is the ability of models to fit random noise. We use the procedure in to measure Rademacher complexity, i.e., computing the average fit to k random relabelings of the training data. The subtask in our set-up acts like a regularizer, increasing the inductive bias of our model, preventing it from learning random patterns in data. Rademacher complexity measures the decrease in ability to learn such patterns. We use the CHUNKS data in these experiments. A model that does not fit to the random data, will be right in 1/22 cases (with 22 labels). We report the Rademacher complexities relative to this. 1.298 1.034 0.990
Our deep single task model increases performance over this baseline by 30%. In contrast, we see that when we predict both POS and the target task at the top layer, Rademacher complexity is lower and close to a random baseline. Interestingly, regularization seems to be even more effective, when the subtask is predicted from a lower layer.
section: Conclusion
MTL and sharing of intermediate representations, allowing supervision signals of different tasks to benefit each other, is an appealing idea. However, in case we suspect the existence of a hierarchy between the different tasks, we show that it is worthwhile to incorporate this knowledge in the MTL architecture's design, by making lower level tasks affect the lower levels of the representation.
