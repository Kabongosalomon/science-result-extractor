section: title
High Accuracy Rule-based Question Classification using Question Syntax and Semantics
section: abstract
We present in this paper a purely rule-based system for Question Classification which we divide into two parts: The first is the extraction of relevant words from a question by use of its structure, and the second is the classification of questions based on rules that associate these words to Concepts. We achieve an accuracy of 97.2%, close to a 6 point improvement over the previous State of the Art of 91.6%. Additionally, we believe that machine learning algorithms can be applied on top of this method to further improve accuracy.
section: Concepts as a Theoretical Framework for Question Classification
Concepts are generalisations or abstractions that allow the use of previous experience in new situations. For example, questions such as "Who is the actor who . . . ?", of the form "Who auxiliary verb (determiner) * Concept:Occupation who . . . ?", can be classified under the class hum:person, if we had information about the Concept "occupation", because this would enable us to map all questions that use any occupation in this particular pattern to this QC. Similarly, information about the Concept "meaning" would enable us to create a rule to classify questions such as "What is the meaning of the word . . . ?", and "What does the word . . . mean?" to the question class desc:definition. As can be seen from the latter example, Concepts need not always be associated with nouns.
section: Implementing Concepts using Types
As described in the previous section, it is useful to define Concepts as sets of words and to this end, we require a method of generating a large number of words that belong to a particular Concept. To achieve this, we make use of Types, which provide away of defining sections of an ontology to belong to a given Type. While the authors use Types to identify classes of nouns that can be compared when measuring the semantic similarity between two sentences, we use Types to define Concepts. In this work, we modify the definition of types by making use of WordNet hyponyms: W 1 is considered a hyponym of W 2 if ∀e ∈ W 1 , e is an instance of W 2 .
A Type consists of a set of WordNet synsets or words S, and represents the set of words whose lemmas belongs to the union of the set S, and in the case of synsets, the set containing the hyponym closure of the synsets in S, and in the case of words, those words. As an example, all words whose lemmas belong to the hyponym closure of the synset 'occupation.n.01', such as bookkeeping, acting, and ministry belong to the the Type 'occupation.n.01'. It is interesting to note that this one definition provides us conceptual information on 283 lemmas (the size of the hyponym closure of occupation.n.01).
We use types to create a rough approximation of Concepts. We achieve this by manually picking specific synsets within WordNet and associating them and all their hyponyms to a particular QC based on wherein a question they appear. Revisiting the first example in Section 3, the Concept "occupation" is defined by creating a Type that includes the word occupation and all hyponyms of the synset 'occupation.n.01'. Similarly, the synsets 'people.n.01', 'organization.n.01', 'university.n.01', 'company.n.04', 'social group.n.01', and all of their hyponyms are assigned to the Question Class "Human Group". Some words, such as the word "mean" discussed in the second example in Section 3, belong to a particular Type while their hyponyms do not (in the case of "mean", "aim", "drive", and "spell" are hyponyms, which do not imply that a question belongs to the definition class the same way the word "mean" does), and in such cases, we add just the word and not its hyponyms.
The manual process of creating Types is done by looking at all hyponyms of the synset entity.n.01 and assigning them to a Type iff that synset and all its hyponyms represent the same Concept. This sometimes leads to instances wherein the same word is part of different Types because of its different word sense. In such cases, Types are redefined using less general synsets.
Not all of the Types we define are directly associated with a Question Class. For example, we define the Type people from, consisting of 'inhabitant.n.01' and all its hyponyms which enables us to identify the class enty:termeq (i.e. equivalent term). We do this by checking to see if the question asks us what people from a particular place call something, by use of the rule "What auxiliary verb people from call word?". As an example, the question "What do Italians call Noodles?" matches this rule and belongs to the QC enty:termeq. We also define groups of verbs as belonging to certain Types, such as the Type of verbs that can only be performed by a person (e.g. sing, invent) and the Type of words that require us to perform a possessive or a prepositional roll (Section 6.1).
section: System Overview
The system presented in this work consists of three parts: a) extracting a Question's Syntactic Map (defined in Section 5.1), b) identifying the headword, of the noun phrase in the question, while handling Entity Identification and phrase detection, and c) using rules to map words at different positions in the Syntactic Map to identify the QC. These are further broken down into the following steps (programmatically, methods):
section: Syntactic Map Extraction
Question Rewrite Rewrites questions that are in non-standard form.
Parse Tree Analysis Extract structure information from the question using Constituency-based parse trees
section: Word, Phrase and Entity Extraction Headword Extraction
Extract headwords from noun phrases in the question using a) Possessive Unrolling b) Preposition Rolling c) Entity Identification
section: Verb, Wh-word and Adjective Extraction
Extract the Auxiliary and Major Verbs, the Wh-word and all adjectives from the question.
section: Rule-based Classification
Match Rules based on the Question Syntax and Word Type
Using a hierarchy of syntactic positions in a question, iteratively check to see if there exists a rule for mapping the word at that position to a QC.
For example, given the question "Name of actress from England in the movie 'The Titanic' is what?", our system identifies its QC as follows: We first identify that this question is not in a form that we can analyse to extract the Syntactic Map and rewrite it as "What is the name of the actress from England in the movie 'The Titanic'?" (Section 5.2). The question's parse tree is then analysed to generate the Question's Syntactic Map (Section 5.1). We then identify the headword to be the noun actress using prepositional rolling (Section 6.1). At this stage, we have established that the question's wh-word is "What", auxiliary verb is "is", and headword is "actress". We check for the existence of a rule that classifies this question by iterating through these elements in a predefined order. This results in the word "actress" matching the rule : 'occupation.n.01' and its hyponyms in SQ-NNP when the wh-word is 'what' indicate that the question class is hum:ind, so enabling us to classify the question as hum:ind.
section: Methodology
To avoid bias, we use the 5,500 questions and their respective question classes provided as training data by for exploration and rule discovery, and ensure that the 500 TREC questions, which consist of the test set, are not observed during the creation of rules (although the system is, at regular intervals, tested on this set to ensure progress). Once we complete the analysis of a question's parse tree, not all words in the question are of further relevance to the task of QC. However, so as to maximise the number of words that we have rules for, we try to create rules for all words that appear in training set.
section: Syntactic Maps
Previous work that has made use of parse trees includes that by, who used Collin's Rules to extract headwords and work by who made use of FrameNet (. Unlike these works, we first extract, what we call, a Question's Syntactic Map, before creating rules that depend on the position of words in this Map.
A Syntactic Map (SM), unlike a parse tree, is a fixed structure that we fill in with information from a question's parse tree and can contain empty or "None" elements. It is a generic template for all the different kinds of questions that we can classify, and any question that we cannot convert to a Syntactic Map, cannot be classified using our system. Crucially, the SM contains the following five elements of a question: a) the question's wh-word b) the noun phrase (if any) contained in the WHNP sub-tree and its internal phrase structure, and from the SQ sub-tree of the parse tree: c) the Auxiliary Verb (AVP) d) the noun phrase (if any) and its internal phrase structure, and e) the Main Verb (MVP) (if any). Noun phrases including possessives, and prepositional phrases are extracted into similar fixed structures. Programmatically, a SM is a class (object-oriented programming), as are the constituent noun phrases, prepositional phrases, and verbs. The generic structure of a SM, along with the structure of its constituents is shown in  In the question "How much does the President get paid ?", it is the adverb "much" that allows us to infer that the expected answer is a number and additionally, the word "paid" allows us to infer that the number, in fact, represents money hence resulting in the question class num:money.
In the questions "What is a golf ball made of ?" and "What does gringo mean ?" the verbs after the noun (the first Main Verb or MVP) provide us with important clues on which question class these questions belong to (in this case enty:substance and desc:def). It is for this reason that we move beyond conventional headword extraction and focus on populating Syntactic Maps, which capture more information about the question. Although Silva et al. (2011) consider words other than nouns, they do so only when the questions contain certain exact phrases.
section: Syntactic Map Extraction
The first step in SM extraction is the extraction of the "WHNP" and "SQ" sections of a question from its constituent parse tree, which we generating using the Stanford CoreNLP toolkit.
The WHNP sub-tree represents the Wh-noun Phrase and the SQ sub-tree the main clause of a whquestion. In cases where there is neither (e.g. Name the highest mountain.), we use the first noun phrase as the SQ sub-tree. From the WHNP and the SQ sections of the parse tree, we extract the various elements of the SM as shown in. This requires the parsing of noun, prepositional, possessive and verb phrases. Due to space constraints, we only provide an overview of each of these below. Additionally, extracting each of these elements is done recursively as sentences often contain possessive phrases or prepositional phrases within one another. illustrates one such scenario in which a question has two recursive possessive phrases.  We make the conscious decision of stopping the SM extraction process after reaching the first main verb. This is because we observed that there were very few questions that require structural information beyond this point.
Our method of analysing noun phrases handles the extraction of adjectives, possessive phrases, prepositions and trailing adjectives but ignores all determiners. Prior to analysing parse trees of noun phrases, we first modify certain parse tree patterns that noun phrases occur in. The resultant Constituency-based parse trees are not always valid but greatly simplify the analysis of noun phrases. Two examples of the modifications we perform to noun phrase sub-trees are illustrated in   This simplification process leaves us with the task of extracting information from noun phrases that belong to a much smaller set of sub-tree patterns. Some of the more common noun phrase patterns are illustrated in. Possessive phrases are treated as nouns that must have, attached to them, yet another noun. When we identify a preposition phrase or a verb phrase, that sub-tree is passed to either the preposition or verb analysis method respectively.
Similarly, we extract information from prepositional sub-trees based on their structure, which nearly   always belong to one of the following three patterns: A preposition phrase with one child that is the preposition and the other that is one of either a noun phrase, verb phrase or another prepositional phrase (e.g. "name of the prime minister of U.K."). These patterns are illustrated in. Just as in the case of noun phrases, we pass on any sub-trees of phrases that are of a different kind to the appropriate analysis module, which enables us to generate a recursive SM.
section: Question Rewrites
There are some questions that do not belong to the standard structure of questions such as "A corgi is a kind of what?" and "In 139 the papal court was forced to move from Rome to where?". We identify several of these structures and create rewrite rules (e.g x is/was y in/of what z?) to rewrite these questions to a form that we can parse. We use regular expressions instead of parse tree analysis as these structures are very easy to identify and so the overhead of parsing is not justified. Using these rules the above two questions will be rewritten as "What is a corgi a kind of?" and "To where was the papal court forced to move from Rome in 139?".
section: Concept Identification
In this section, we provide details on methods we use for identifying relevant Concepts, which we extract by analysing the SM.
section: Preposition Rolling and Possessive Unrolling
Rolling and Unrolling refer to the selective moving forward through a preposition, or backwards through a possessive noun. Consider the question "What is the quantity of American soldiers still unaccounted for from the Vietnam war?" from which we extract quantity(PP) of PP-NN:(JJ)American soldiers, and the question "What are the different types of plastic?" from which we extract (JJ)different types(PP) of PP-NN: plastic. In the second instance, we must roll through the preposition to reach the relevant word "plastic", whereas, in the first instance, we must not, so identifying "quantity'.
Similarly, consider the question "What game's board shows the territories of Irkutsk, Yakutsk and Kamchatka?" from which we extract the noun phrase (Possessive)game board, and the question "Name Alvin's brothers." from which we extract (Possessive)Alvin brothers. In the first instance we need to unroll through the possessive to reach the relevant word "game", whereas in the second case we must not. We call this selective process of moving forward through a preposition "Rolling", and the process of selectively moving backwards through a possessive "Unrolling". Rolling and Unrolling are achieved through a list of rules that depend on the Type of the target and source of the Roll or Unroll.
section: Headword and Phrase Extraction
Consider the question "What mystery writer penned '...the glory that was Greece, and the grandeur that was Rome'?". The relevant noun phrase that we extract from the SM is "mystery writer" and the head of this noun phrase is "writer", the last noun in the noun phrase. This is often the case, and some previous works have used only this to identify the head of a noun phrase). Unfortunately, this is not always the case, and does not always provide the word that is most useful for QC. For example, the noun phrase extracted from "What crop failure caused the Irish Famine?" is "crop failure" and the relevant noun is "crop". Although it can be argued that the head noun in this phrase is "failure", qualified by "crop", this would not aid us in classification, as "crops" area form of food and the expected Question Class is enty:food, while "failure" is a very different Concept.
We automatically identifying the head noun by identifying Verb Nouns and Descriptive Nouns starting at the right of the noun phrase and ignoring such nouns. We define Verb Nouns as nouns that have a more common verb form (e.g. fail) or verbs that are "acts", which we identify by parsing the definition of the verb. Similarly, we define Descriptive Nouns as nouns that belong to a Type we define as descriptive which includes, for example, hyponyms of the synyset 'digit.n.01'.
section: Entity Identification
Let us now consider the question "What is bipolar disorder?". The correct Question Class for this question is desc:definition, however, it is easy to miss-classify this question as belonging to the class enty:dismed (entity, disease or medicine), because the word "bipolar" is tagged as an adjective. To get around this we require a method of identifying that "bipolar disorder" must be considered as a single entity.
Even in instances wherein it is relatively easy to identify an entity, as in the case of phrases that consist of consecutive nouns, it is important to be able to convert these phrases to a form that appears in WordNet. For example, the phrase "equity securities" can be identified as a single entity, however, it is listed in WordNet under the entry "Shares".
We identify these phrases using a method called Wikification (, which is the process of linking words and phrases in apiece of text to titles of Wikipedia entries. The intuition behind this is that a phrase that appears as a Wikipedia Article title must be important enough to be considered as a single Entity. We base our method of Wikification on the original, while replacing the process of keyword identification with SM and that of Word Sense Disambiguation with the method detailed in Section 7.1. For example, there is an article on Wikipedia titled "Bipolar Disorder" on Wikipedia and the Wikified term for "equity securities" is "Shares".
section: Question Classification using Syntactic Maps
Once we have the SM of a question, we use rules to identify the relevant QC. However, before we can match appropriate words, we require away of identifying the correct sense of a word.
section: Word Sense Disambiguation
SMs often provide us with a single word that represents the object that the question expects as an answer. The question "What album put The Beatles on the cover of Time in 1967 ?", for example, requires that the answer consists of an "album". However, it is unclear whether album refers to "one or more recordings issued together" or "a book of blank pages with pockets or envelopes". address this problem by use of the Lesk Algorithm.
Our use of SM allows for implicit Word Sense Disambiguation as it is rare for the same word to appear at the same syntactic location but in different senses. When this does happen however, we identify the sense of a word based on the Types of the surrounding elements of the SM. For example, "How much does it cost to fly to Japan?" and "How much does a plane weigh?" both have the word "much" at the same position and so require us to identify the Types of associated words (i.e. "cost" and "weigh") to be able to disambiguate the relevant Concept.
section: Mapping Question Classes
The intuition behind the mapping process is that words or phrases at certain positions in the SM trigger certain Concepts, which gives away the question class. To this end, we use Types defined for each different position in the SM to map questions to question classes. For example, the word "do" appearing as the  if AVP is one of "is", "are", "was", "were" then There are some special words, such as "much", "do", "name" and "call", that require more complex classification rules. The adjective "much" for example could indicate the class num:money or num:weight depending on whether the other sections of the SM contain the Type "money" or the Type "weight". As in the case of WSD, we define disambiguation rules for each such word.
Algorithm 1, while not exhaustive in listing the mapping rules (due to space constraints), provides a simplified overview of the mapping of Semantic Maps to Question Classes. It takes as input the SM, the Type definitions and associated Question Classes and returns a tuple consisting of the Major and Minor question classes. Just over 230 Type definitions and 10 special Word Sense Disambiguation definitions cover the entire test set, and at the time of writing, these have been expanded to around 600 Type definitions and 70 WSD definitions.
section: Results
We achieve an accuracy of 97.2% on the TREC 10 dataset which translates to an incorrect tagging of 14 of the 500 questions in the dataset. This is close to a 6 point improvement over the previous state of the art of 91.6% (Van-Tu and Anh-Cuong, 2016). We list our accuracy against that of various other works that have reported results on the TREC 10 dataset in: Results Achieved by this Work alongside some other Works that use the same Dataset. provides a list of some of the questions that we misclassify along with the reason for this. One of the advantages of a purely rule-based system is the ability to pinpoint the exact reason for an incorrect classification.
section: Error Analysis
section: Question Correct Class Classified As Reason
What are the twin cities? LOC city DESC def We classify both these as definitions because we (correctly) identify "twin cities" and "speed of light" as entities. The presence of the word "the" however requires information about the entity instead of a definition for the entity -a rule that requires to be added.
What is the speed of light? NUM speed DESC def
What is compounded interest? DESC def DESC desc
Our Wikification system fails to identify "compounded interest" to be the same as the entity "compound interest".
What is the spirometer test? DESC def ENTY instru
The word "test", has a natural verb form so forcing the system to identify "spirometer" as the head noun. Some modifications to the function identifying Verb Nouns are required to rectify this.: An analysis of some of the questions that we fail to classify correctly.
section: Conclusion and Future Work
We presented a purely rule-based system for QC which exploits decades of research into the structure of language and Concepts. Although this method has focused on a particular type of questions, we believe that a similar method can be applied to classifying questions of a different type, and we intend to extend our work to include those datasets. We also note that these area common and important kind of questions, which are similar to those handled by most modern smartphone interactive systems such as Google Now. Finally, we intend to implement a QA system that leverages QC to explore the true impact of highaccuracy question classification. We also intend to make this system available through a simple Application Programming Interface (API) 1 soother QA systems can benefit from this work.
