section: title
Empower Sequence Labeling with Task-Aware Neural Language Model
section: abstract
Linguistic sequence labeling is a general approach encompassing a variety of problems, such as part-of-speech tagging and named entity recognition. Recent advances in neu-ral networks (NNs) make it possible to build reliable models without handcrafted features. However, in many cases, it is hard to obtain sufficient annotations to train these models. In this study, we develop a neural framework to extract knowledge from raw texts and empower the sequence labeling task. Besides word-level knowledge contained in pre-trained word embeddings, character-aware neural language models are incorporated to extract character-level knowledge. Transfer learning techniques are further adopted to mediate different components and guide the language model towards the key knowledge. Comparing to previous methods, these task-specific knowledge allows us to adopt a more concise model and conduct more efficient training. Different from most transfer learning methods, the proposed framework does not rely on any additional supervision. It extracts knowledge from self-contained order information of training sequences. Extensive experiments on benchmark datasets demonstrate the effectiveness of leveraging character-level knowledge and the efficiency of co-training. For example, on the CoNLL03 NER task, model training completes in about 6 hours on a single GPU, reaching F1 score of 91.71±0.10 without using any extra annotations.
section: Introduction
Linguistic sequence labeling is a fundamental framework. It has been applied to a variety of tasks including part-ofspeech (POS) tagging, noun phrase chunking and named entity recognition (NER). These tasks play a vital role in natural language understanding and fulfill lots of downstream applications, such as relation extraction, syntactic parsing, and entity linking ().
Traditional methods employed machine learning models like Hidden Markov Models (HMMs) and Conditional Random Fields (CRFs), and have achieved relatively high performance. However, these methods have a heavy reliance on handcrafted features (e.g., whether a word is capitalized) and language-specific resources (e.g., gazetteers). Therefore, it could be difficult to apply them to new tasks or shift to new domains. To overcome this drawback, neural networks (NNs) have been proposed to automatically extract features during model learning. Nevertheless, considering the overwhelming number of parameters in NNs and the relatively small size of most sequence labeling corpus, annotations alone may not be sufficient to train complicated models. So, guiding the learning process with extra knowledge could be a wise choice.
Accordingly, transfer learning and multi-task learning have been proposed to incorporate such knowledge. For example, NER can be improved by jointly conducting other related tasks like entity linking or chunking (. After all, these approaches would require additional supervision on related tasks, which might be hard to get, or not even existent for low-resource languages or special domains.
Alternatively, abundant knowledge can be extracted from raw texts, and enhance a variety of tasks. Word embedding techniques represent words in a continuous space ( and retain the semantic relations among words. Consequently, integrating these embeddings could be beneficial to many tasks (). Nonetheless, most embedding methods take a word as a basic unit, thus only obtaining word-level knowledge, while character awareness is also crucial and highly valued inmost state-ofthe-art NN models.
Only recently, character-level knowledge has been leveraged and empirically verified to be helpful in numerous sequence labeling tasks (. Directly adopting pre-trained language models, character-level knowledge can be integrated as context embeddings and demonstrate its potential to achieve the state-of-the-art). However, the knowledge extracted through pre-training is not task-specific, thus containing a large irrelevant portion. So, this approach would require a bigger model, external corpus and longer training. For example, one of its language models was trained on 32 GPUs for more than half a month, which is unrealistic in many situations.
In this paper, we propose an effective sequence labeling framework, LM-LSTM-CRF, which leverages both wordlevel and character-level knowledge in an efficient word-level lstm unit concat unit c0, c1,0 c1,1 c1,2 c1,3 c1,4 c1,5 c1, c2,0 c2,1 c2,2 c2,3 c2,4 c2,5 c2,
backward-to-SL highway backward-to-LM highway forward-to-SL highway forward-to-LM highway x: LM-LSTM-CRF Neural Architecture model with the sequence labeling task and conduct multitask learning to guide the language model towards taskspecific key knowledge. Besides the potential of training a better model, this strategy also poses anew challenge. Based on our experiments, when the tasks are discrepant, language models could be harmful to sequence labeling in a na¨ıvena¨ıve co-training setting. For this reason, we employ highway networks to transform the output of character-level layers into different semantic spaces, thus mediating and unifying these two tasks. For word-level knowledge, we choose to fine-tune pre-trained word embeddings instead of co-training or pretraining the whole word-level layers, because the majority of parameters in word-level layers come from the embedding layer and such co-training or pre-training cost lots of time and resources. We conduct experiments on the CoNLL 2003 NER task, the CoNLL 2000 chunking task, as well as the WSJ portion of the Penn Treebank POS tagging task. LM-LSTM-CRF achieves a significant improvement over the state-of-the-art. Also, our co-training strategy allows us to capture more useful knowledge with a smaller network, thus yielding much better efficiency without loss of effectiveness.
section: LM-LSTM-CRF Framework
The neural architecture of our proposed framework, LM-LSTM-CRF, is visualized in. For a sentence with annotations y = (y 1 , . . . , y n ), its word-level input is marked as x = (x 1 , x 2 , . . . , x n ), where xi is the ith word; its character-level input is recorded as c = (c 0, , c 1,1 , c 1,2 , . . . , c 1, , c 2,1 , . . . , c n, ), where c i,j is the j-th character for word w i and c i, is the space character after w i . These notations are also summarized in. Now, we first discuss the multi-task learning strategy and then introduce the architecture in a bottom-up fashion.
x word-level input
output of backward character-level LSTM at c i, f Li output of forward-to-LM highway unit r Li output of backward-to-LM highway unit f Ni output of forward-to-SL highway unit r Ni output of backward-to-SL highway unit vi input of word-level bi-LSTM at xi z i output of word-level bi-LSTM at xi
section: Multi-task Learning Strategy
As shown in, our language model and sequence labeling model share the same character-level layer, which fits the setting of multi-task learning and transfer learning. However, different from typical models of this setting, our two tasks are not strongly related. This discordance makes our problem more challenging. E.g., although a naive co-training setting, which directly uses the output from character-level layers, could be effective in several scenarios, for our two tasks, it would hurt the performance. This phenomenon would be further discussed in the experiment section.
To mediate these two tasks, we transform the output of character-level layers into different semantic spaces for different objectives. This strategy allows character-level layers to focus on general feature extraction and lets the transform layers select task-specific features. Hence, our language model can provide related knowledge to the sequence labeling, without forcing it to share the whole feature space.
section: Character-level Layer
Character-level neural language models are trained purely on unannotated sequence data but can capture the underlying style and structure. For example, it can mimic Shakespeare's writing and generate sentences of similar styles, or even master the grammar of programming languages (e.g., XML, LA T E X, and C) and generate syntactically correct codes. Accordingly, we adopted the character-level Long Short Term Memory (LSTM) networks to process character-level input. Aiming to capture lexical features instead of remembering words' spelling, we adjust the prediction from the next character to the next word. As in, the character-level LSTM would only make predictions for the next word at word boundaries (i.e., space characters orc i, ).
Furthermore, we coupled two LSTM units to capture information in both forward and backward directions. Although it seems similar to the bi-LSTM unit, the outputs of these two units are processed and aligned differently. Specifically, we record the output of forward LSTM at c i, as f i , and the output of backward LSTM at c i, as r i .
section: Highway Layer
In computer vision, Convolutional Neural Networks (CNN) has been proved to bean effective feature extractor, but its output needs to be further transformed by fully-connected layers to achieve the state-of-the-art. Bearing this in mind, it becomes natural to stack additional layers upon the flat character-level LSTMs. More specifically, we employ highway units (Srivastava, Greff, and Schmidhuber 2015), which allow unimpeded information flowing across several layers. Typically, highway layers conduct nonlinear transformation as
is element-wise product, g(·) is a nonlinear transformation such as ReLU in our experiments, t = σ(W T n + b T ) is called transform gate and (1 − t) is called carry gate.
In our final architecture, there are four highway units, named forward-to-LM, forward-to-SL, backward-to-LM, and backward-to-SL. The first two transfer f i into f Li and f Ni , and the last two transfer r i into r Li and r Ni . f Li and r Li are used in the language model, while f Ni and r Ni are used in the sequence labeling.
section: Word-level Layer
Bi-LSTM is adopted as the word-level structure to capture information in both directions. As shown in, we concatenate f Ni and r N i−1 with word embeddings and then feed them into the bi-LSTM. Note that, in the backward character-level LSTM, c i−1, is the space character before word xi , therefore, f Ni would be aligned and concatenated with r N i−1 instead of r Ni . For example, in, the word embeddings of 'Pierre' will be concatenated with the output of the forward-to-SL over '. . .Pierre ' and the output of the backward-to-SL over '. . .erreiP '.
As to word-level knowledge, we chose to fine-tune pretrained word embeddings, instead of co-training the whole word-level layer. This is because most parameters of our word-level model come from word embeddings, and finetuning pre-trained word embeddings have been verified to be effective in leveraging word-level knowledge. Besides, current word embedding methods can easily scale to the large corpus; pre-trained word embeddings are available in many languages and domains. However, this strategy cannot be applied to character-level layers, since the embedding layer of character-level layers contains very few parameters. Based on these considerations, we applied different strategies to leverage word-level knowledge from character-level.
section: CRF for Sequence Labeling
Label dependencies are crucial for sequence labeling tasks. For example, in NER task with BIOES annotation, it is not only meaningless but illegal to annotate I-PER after B-ORG (i.e., mixing the person and the organization). Therefore, jointly decoding a chain of labels can ensure the resulting label sequence to be meaningful. Conditional random field (CRF) has been included inmost state-of-the-art models to capture such information and further avoid generating illegal annotations. Consequently, we build a CRF layer upon the word-level LSTM.
For training instance (x i , c i , y i ), we suppose the output of word-level LSTM is Z i = (z i,1 , z i,2 , . . . , z i,n ). CRF models describe the probability of generating the whole label sequence with regard to
is a generic label sequence. Similar to (Ma and Hovy 2016), we define this probability as follows.
Here, Y(Z) is the set of all generic label sequences, φ(y j−1 , y j , z j ) = exp(W yj−1,yj z i + b yj−1,yj ), where W yj−1,yj and b yj−1,yj are the weight and bias parameters corresponding to the label pair (y j−1 , y j ). For training, we minimize the following negative loglikelihood.
And for testing or decoding, we want to find the optimal sequence y * that maximizes the likelihood.
Although the denominator of Eq. 1 is complicated, we can calculate Eqs. 2 and 3 efficiently by the Viterbi algorithm.
section: Neural Language Model
The language model is a family of models describing the generation of sequences. Ina neural language model, the generation probability of the sequence x = (x 1 , ..., x n ) in the forward direction (i.e., from left to right) is defined as
. This probability is assumed as
where w xi is the weight vector for predicting word xi . In order to extract knowledge in both directions, we also adopted a reversed-order language model, which calculates the generation probability from right to left as
The following negative log likelihood is applied as the objective function of our language model.
section: Joint Model Learning
By combining Eqs. 2 and 4, we can write the joint objective function as
where λ is a weight parameter. In our experiments, λ is always set to 1 without any tuning. In order to train the neural network efficiently, stochastic optimization has been adopted. And at each iteration, we sample a batch of training instances and perform an update according to the summand function of Eq. 5:
section: Experiments
Here. We report the accuracy for the WSJ dataset. And in the first two datasets, we adopt the official evaluation metric (microaveraged F 1 ), and use the BIOES scheme (. Also, in all three datasets, rare words (i.e., frequency less than 5) are replaced by a special token (<UNK>).
section: Network Training
For a fair comparison, we didn't spend much time on tuning parameters but borrow the initialization, optimization method, and all related hyper-parameter values (except the state size of LSTM) from the previous work. For the hidden state size of LSTM, we expand it from 200 to 300, because introducing additional knowledge allows us to train a larger network. We will further discuss this change later. summarizes some important hyperparameters. Since the CoNLL00 is similar to the CoNLL03 NER dataset, we conduct experiments with the same parameters on both tasks. Initialization. We use GloVe 100-dimension pre-trained word embeddings released by Stanford 1 and randomly initialize the other parameters (Glorot and Bengio 2010; Jozefowicz, Zaremba, and Sutskever 2015). Optimization. We employ mini-batch stochastic gradient descent with momentum. The batch size, the momentum and the learning rate are set to 10, 0.9 and η t = η0 1+ρt , where η 0 is the initial learning rate and ρ = 0.05 is the decay ratio. Dropout is applied in our model, and its ratio is fixed to 0.5. To increase stability, we use gradient clipping of 5.0. Network Structure. The hyper-parameters of characterlevel LSTM are set to the same value of word-level bi-LSTM. We fix the depth of highway layers as 1 to avoid an over-complicated model. Note that some baseline methods (e.g.,) incorporate the development set as apart of training. However, because we are using early stopping based on the evaluation on the development set, our model is trained purely on the training set.
Compared Methods We consider three classes of baseline sequence labeling methods in our experiments.
•
section: Performance Comparison
In this section, we focus on the comparisons between LM-LSTM-CRF and previous state-of-the-arts, including both effectiveness and efficiency. As demonstrated in Tables 4, 5 and 7, LM-LSTM-CRF significantly outperforms all baselines without additional resources. Moreover, even for those baselines with extra resources, LM-LSTM-CRF beats most of them and is only slightly worse than TagLM (index 4) (. During our experiments, we discover that, when trained on CPU, LSTM-CNN-CRF only reaches 90.83 F 1 score on the NER dataset, but gets 91.37 F 1 score when trained on GPU. We conjecture that this performance gap is due to the difference of runtime environments. Therefore, we conduct all of our experiments on GPU. Additionally, we can observe that, although co-trained with language model, results of index 12 fails to outperform LSTM-CNN-CRF or LSTM-CRF. The reason of this phenomenon could be complicated and beyond the scope of this paper. However, it verified the effectiveness of our method, and demonstrated the contribution of outperforming these baselines.
NER First of all, we have to point out that the results of index 1, 4, 8, 10 and 11 are not directly comparable with others since their final models are trained on both training and development set, while others are trained purely on the training set. As mentioned before, LM-LSTM-CRF outperforms all baselines except TagLM (index 4). For a thorough comparison, we also compare to its variants, TagLM (index 5), TagLM (index 10) and TagLM (index 11). Both index 10 and 11 are trained on the CoNLL03 dataset alone, while index 11 utilizes language model and index 10 doesn't. Comparing F 1 scores of these two settings, we can find that TagLM (index: Training statistics of TagLM (index 4 and 5) and LM-LSTM-CRF on the CoNLL03 NER dataset.
11) even performs worse than TagLM (index 10) , which reveals that directly applying co-training might hurt the sequence labeling performance. We will also discuss this challenge later in the Highway Layers & Co-training section. Besides, changing the forward language model from 4096-8192-1024 to LSTM-2048-512, TagLM (index 5) gets a lower F 1 score of 91.62±0.23. Comparing this score to ours (91.71±0.10), one can verify that pre-trained language model usually extracts a large portion of unrelated knowledge. Relieving such redundancy by guiding the language model with task-specific information, our model is able to conduct both effective and efficient learning.
POS Tagging Similar to the NER task, LM-LSTM-CRF outperforms all baselines on the WSJ portion of the PTB POS tagging task. Although the improvements over LSTM-CRF and CNN-LSTM-CRF are less obvious than those on the CoNLL03 NER dataset, considering the fact that the POS tagging task is believed to be easier than the NER task and current methods have achieved relatively high performance, this improvement could still be viewed as significant. Moreover, it is worth noting that for both NER and POS tagging tasks, LM-LSTM-CRF achieves not only higher F 1 scores, but also with smaller variances, which further verifies the superiority of our framework. Chunking In the chunking task, LM-LSTM-CRF also achieves relatively high F 1 scores, but with slightly higher variances. Considering the fact that this corpus is much smaller than the other two (only about 1/5 of WSJ or 1/2 of CoNLL03 NER), we can expect more variance due to the   Efficiency We implement LM-LSTM-CRF 5 based on the PyTorch library . Models has been trained on one GeForce GTX 1080 GPU, with training time recorded in.
In terms of efficiency, the language model component in LM-LSTM-CRF only introduces a small number of parameters in two highway units and a soft-max layer, which may not have a very large impact on the efficiency. To control variables like infrastructures, we further reimplemented both baselines, and report their performance together with original implementations. From the results, these re-implementations achieve better efficiency comparing to the original ones, but yield relative worse performance. Also, LM-LSTM-CRF achieves the best performance, and takes twice the training time of the most efficient model, LSTM-CNN-CRF . Empirically, considering the difference among the implementations of these models, we think these methods have roughly the same efficiency.
Besides, we list the required time and resources for pretraining model index 4 and 5 on the NER task in Table 6 (). Comparing to these language models pre-trained on external corpus, our model has no such reliance on extensive corpus, and can achieve similar performance with much more concise model and effi-
section: Analysis
To analyze the performance of LM-LSTM-CRF, we conduct additional experiments on the CoNLL03 NER dataset.
Hidden State Size To explore the effect of model size, we train our model with different hidden state sizes. For comparison, we also apply the same hidden state sizes to LSTM-CRF and LSTM-CNN-CRF. From, one can easily observe that the F 1 score of LM-LSTM-CRF keeps increasing when the hidden state size grows, while LSTM-CNN-CRF has a peak at state size 200 and LSTM-CRF has a drop at state size 200. This phenomenon further verified our intuition of employing the language model to extract knowledge and prevent overfitting.
Highway Layers & Co-training To elucidate the effect of language model and highway units, we compare LM-LSTM-CRF with its two variants, LM-LSTM-CRF NL and LM-LSTM-CRF NH. The first keeps highway units, but optimizes J CRF alone; the second jointly optimizes J CRF and J LM , but without highway units. As shown in, LM-LSTM-CRF NH yields worse performance than LM-LSTM-CRF NL. This observation accords with previous comparison between TagLM (index 10) and TagLM (index 11) on the CoNLL03 NER dataset. We conjecture that it is because the NER task and the language model is not strongly related to each other. In summary, our proposed co-training strategy is effective and introducing the highway layers is necessary.
section: Related Work
There exist two threads of related work regarding the topics in this paper, which are sequence labeling and how to improve it with additional information.. These models all incorporate character-level structure, and report meaningful improvement over pure wordlevel model. Also, CRF layer has also been demonstrated to be effective in capturing the dependency among labels. Our model is based on the success of LSTM-CRF model and is further modified to better capture the char-level information in a language model manner.
Leveraging Additional Information. Integrating wordlevel and character-level knowledge has been proved to be helpful to sequence labeling tasks. For example, word embeddings ( can be utilized by co-training or pre-training strategies (). However, none of these models utilizes the character-level knowledge. Although directly adopting character-level pre-trained language models could be helpful (). Such pretrained knowledge is not task-specific and requires a larger neural network, external corpus, and longer training. Our model leverages both word-level and character-level knowledge through a co-training strategy, which leads to a concise, effective, and efficient neural network. Besides, unlike other multi-task learning methods, our model has no reliance on any extra annotation () or any knowledge base (). Instead, it extracts knowledge from the self-contained order information.
section: Conclusion
In this paper, we proposed a sequence labeling framework, LM-LSTM-CRF, which effectively leverages the language model to extract character-level knowledge from the selfcontained order information. Highway layers are incorporated to overcome the discordance issue of the naive cotraining Benefited from the effectively captured such taskspecific knowledge, we can build a much more concise model, thus yielding much better efficiency without loss of effectiveness (achieved the state-of-the-art on three benchmark datasets) . In the future, we plan to further extract and incorporate knowledge from other "unsupervised" learning principles and empower more sequence labeling tasks.
