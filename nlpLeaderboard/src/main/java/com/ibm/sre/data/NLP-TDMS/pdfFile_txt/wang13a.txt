section: title
Fast dropout training
section: abstract
Preventing feature co-adaptation by encouraging independent contributions from different features often improves classification and regression performance. Dropout training (Hinton et al., 2012) does this by randomly dropping out (zeroing) hidden units and input features during training of neural networks. However, repeatedly sampling a random subset of input features makes training much slower. Based on an examination of the implied objective function of dropout training , we show how to do fast dropout training by sampling from or integrating a Gaussian approximation, instead of doing Monte Carlo optimization of this objective. This approximation , justified by the central limit theorem and empirical evidence, gives an order of magnitude speedup and more stability. We show how to do fast dropout training for classification , regression, and multilayer neural networks. Beyond dropout, our technique is extended to integrate out other types of noise and small image transformations.
section: Introduction
Recent work () has shown that preventing feature co-adaptation by dropout training is a promising method for regularization. Applied to neural network training, the idea is to dropout (zero) randomly sampled hidden units and input features during each iteration of optimization. Dropout played an important role in the systems that won recent learning competitions such as ImageNet classification () and the Merck molecular activity challenge at www.kaggle.com, and improves performance on various tasks. Dropout can be considered another approach to regularization in addition to the widely used parameter shrinkage methods and model averaging. This process lowers the trust in a feature that is only helpful when other specific features are present, since any particular feature maybe dropped out and cannot be depended on. Alternatively, the procedure can be seen as averaging over many neural networks with shared weights.
Other observations of harmful co-adaptation and ways to address them exist in the literature. Naive Bayes, by completely ignoring co-adaptation, performs better than discriminative methods when there is little data, and continues to perform better on certain relatively large datasets). In (), it is observed that training involves trade-offs among weights, where the presence of highly indicative features can cause other useful but weaker features to undertrain. They propose feature bagging: training different models on subsets of features that are later combined, an idea further pursued under the name logarithmic opinion pools by). Improved performance on Named Entity Recognition and Part-of-Speech Tagging was demonstrated.
While the effectiveness of these methods in preventing feature co-adaptation has been demonstrated, actually sampling, or training multiple models, make training slower. Moreover, with a dropout rate of p, the proportion of data still not seen after n passes is p n (e.g., 5 passes of the data are required to see 95% of it at p = 0.5). If the data is not highly redundant, and if we make the relevant data only partially observable at random, then the task becomes even harder, and training efficiency may reduce further.
In this paper, we look at how to achieve the benefit of dropout training without actually sampling, thereby using all the data efficiently. The approach uses a Gaussian approximation that is justified by the central limit theorem and empirical evidence. We show the validity of this approximation and how it can provide an order of magnitude speed-up at training time, while also giving more stability. Fast dropout fits into the general framework of integrating out noise added to the training data. See (van der) for an alternative approach to integrating out noise and a survey of related work from that angle. Their approach is exact for loss functions decomposable by the moment generating function of the independent noise such as the exponential loss and squared error loss. Our approach does not require independence: it can integrate out small transformations that an image classifier should be invariant to. We begin with logistic regression for simplicity, then extend the idea to other loss functions, other noise, and neural networks. Code is provided at the author's website.
section: Fast approximations to dropout
section: The implied objective function
We illustrate the idea with logistic regression (LR) given training vector x, and label y ∈ {0, 1}. To train LR with dropout on data with dimension m, first sample z i ∼ Bernoulli(p i ) for i = 1...m. Here pi is the probability of not dropping out input xi . After sampling z = {z i } i=1...m we can compute the stochastic gradient descent (sgd) update as follows:
where D z = diag(z) ∈ R m×m , and σ(x) = 1/(1 + e −x ) is the logistic function.
This update rule, applied over the training data for multiple passes, can be seen as a Monte Carlo approximation to the following gradient:
The objective function with the above gradient is the expected conditional log-likelihood of the label given the data with dropped out dimensions indicated by z,
. This is the implied objective function for dropout training:
Since we are just taking an expectation, we still have a convex optimization problem provided that the negative log-likelihood is convex.
Evaluating the expectation in (1) naively by summing overall possible z has complexity O(2 m m). Rather than directly computing the expectation with respect to z, we propose a variable transformation that allows us to approximately compute the expectation with respect to a simple random variable Y ∈ R, instead of z ∈ {0, 1} m . In the next subsection, we describe an efficient O(m) approximation that is accurate for machine learning applications where w ix i usually come from a unimodal or bounded distribution. As z is repeatedly sampled, the resulting inputs to the top unit are close to being normally distributed.
We make the observation that evaluating the objective function L(w) involves taking the expectation with respect to the variable Y (z) = w TD z x = mi w ix i z i , a weighted sum of Bernoulli random variables. For most machine learning problems, {w i } typically forms a unimodal distribution centered at 0, {x i } is either unimodal or in a fixed interval. In this case, Y can be well approximated by a normal distribution even for relatively low dimensional data with m = 10. More technically, the Lyapunov condition is generally satisfied fora weighted sum of Bernoulli random variables of the form Y that are weighted by real data (. Then, Lyapunov's central limit theorem states that Y (z) tends to a normal distribution as m → ∞ (see). We empirically verify that the approximation is good for typical datasets of moderate dimensions, except when a couple of dimensions dominate all others (see. Finally, let S be the
where
In the following subsections, based on the Gaussian assumption above, we present several approximations at different tradeoff points between speed and accuracy. In the end, we present experimental results showing that there is little to no performance loss when using the faster, less accurate approximations.
section: Gradient computation by sampling from the Gaussian
Given good convergence, we note that drawing samples of the approximating Gaussian S of Y (z), a constant time operation, is much cheaper than drawing samples of Y (z) directly, which takes O(m). This effect is very significant for high dimensional datasets. So without doing much, we can already approximate the objective function (2) m times faster by sampling from S instead of Y (z). Empirically, this approximation is within the variance of the direct MC approximation of by taking 200 samples of z.
Approximating the gradient introduces a complication when using samples from the Gaussian. The gradient
] works poorly in terms of both approximation error and final performance. Note that g(z) is a linear function and therefore
A good way to approximate (4) is by analytically taking the expectation with respect to z i and then using a linear approximation to the conditional expectation. More precisely, consider dimension i of the gradient:
where z −i is the collection of all other zs except z i ,
i w 2 i are the changes in µ S , σ 2 S due to conditioning on z i . Note that the partial derivatives as well as E S∼N (µ S ,σ 2 S ) [f (S)] only need to be computed once per training case, since they are independent of i. α, β, γ can be computed by drawing K samples from S, taking time O(K) (whereas K samples of Y (z) take time O(mK)). Concretely,
can be computed by differentiating inside the expectation.
One can combine and what we do in below to obtain a more accurate yet relatively cheap approximation to the derivative. However, in practice, using only β approximates the derivative to within the variance of successive MC computations of the objective L (see). Empirically, this is 2-30 times faster compared to MC dropout (see and table 1).
At a slightly higher loss inaccuracy, we can get rid of z completely by re-parameterizing the problem in µ sand σ sand taking derivatives with respect to them instead of approximating the derivative directly. So the objective function (2) becomes
section: A closed-form approximation
In the binary classification case, we can avoid sampling by tabulating α, β, γ, and their partial derivatives (they are just functions of 2 arguments). Interestingly, an accurate closed-from approximation is also possible by using the Gaussian cumulative distribution function Φ(x) = 1 √ 2π
x −∞ e −t 2 /2 dt to approximate the logistic function. It can be shown by parameter differentiation with respect to µ and then integrating with respect to µ that
This is an approximation that is used for Bayesian prediction when the posterior is approximated by a Gaussian. As we now have a closed-form approximation of α, one can also obtain expressions for β and γ by differentiating.
Furthermore, by substituting x = µ+st, differentiating with respect to µ, and, we can even approximate the objective function (6) in a closed-form:
The actual objective as defined in can be obtained from the above by observing that 1 − σ(x) = σ(−x).
The gradient and Hessian with respect tow can be found by analytically differentiating.
section: Generalizations
section: Least squares regression
In contrast to all the approximations so far, dropout training of regression with squared error loss can be computed exactly. Let y be the true label andˆYandˆ andˆY = i w ix i z i be the predicted label with
By the bias-variance decomposition, the expected squared error loss is
Since is completely determined by the mean and variance ofˆYofˆ ofˆY , it does not matter which distributionˆY distributionˆ distributionˆY comes from as long as µ and s 2 are matched. As a result, (9) is also the exact loss function of the original dropout objective if we summed over z i instead. So over the whole dataset of size n, dropout regression has the following equivalent objective:
This is a form of L 2 regularization depending on
so that weights of larger features are regularized more strongly.
Alternatively, let X ∈ R n×m be the design matrix, then the normal equations for dropout training and ridge regression are, respectively,
where diag(A) represents the diagonal matrix with the same diagonal as A. The diagonal of X TX is stronger by a multiplicative factor 1 + λ for dropout instead of the additive λI for L 2 . The equivalent value for λ determined by dropout is (1 − p)/p.
section: Hinge loss and the Maxout unit
Our apporach can be applied to the classical hinge loss and the recently proposed maxout network). The structured SVM loss is
where Y is the set of possible predictions and (y, y ) is the loss incurred by predictingˆypredictingˆ predictingˆy when the true label is y. The maxout unit computes
Under the fast dropout approach, both of these reduce to the problem of computing the maximum of Gaussians maxi X i for X i ∼ N (µ(x, w i ), σ 2 (x, w i )) not necessarily indepedent. Several approaches to this problem is presented in (Ross, 2010).
section: Softmax and general loss
Unfortunately, the best way to compute the crossentropy loss for softmax seems to be sampling from the input Gaussian directly with S ∈ R |Y| where Y is the set of possible predictions.
where softmax(s) i = e si / |Y| j=1 e sj and Σ = U UT . The required partial derivatives can again be computed by differentiating inside the expectation. This is also the general way to do fast dropout training on output units that maybe vector-valued functions of vectors.
section: Transformation invariance as noise
More image data can be generated by applying transformations like small translations, rotations, shearing etc. to the original training data. A transformation of magnitude can be approximated locally by its Lie derivative as T α (x) = x + L T,x (Simard et al., 1996). For translation, rotation, shearing, we can generate more data by randomly sampling i ∼ N (0, σ 2 i ) and computing X = x+ ii Li . Notice that w TX is again normally distributed and the techniques presented in this paper can be used to integrate out these transformations without actually generating the transformed data. Here we do not need the central limit theorem and the noise is not independent.
section: Other noise
Like the exact approach in (van der, the Gaussian approximation can be applied to other noise models (Poisson, Gaussian, etc). We just need to characterize the noise in terms of its mean and variance and rely on the central limit theorem.
section: Fast dropout for neural networks
Dropout training, as originally proposed, was intended for neural networks where hidden units are dropped out, instead of the data. Fast dropout is directly applicable to dropping out the final hidden layer of neural networks. In this section, we approximately extend our technique to deep neural networks and show how they apply to several popular types of hidden units. For the last layer of a neural network, any output unit outlined in section 3 can be used.
section: The hidden layers
Under dropout training, each hidden unit takes a random variable as input, and produces a random variable as output. When the number of hidden units is more than 10 or so, we may again approximate their inputs as Gaussians and characterize their outputs by the output means and variances. A complication is that the inputs to hidden units have a covariance as shown in.
Consider any hidden unit in dropout training. We may approximate its input as a Gaussian variable X ∼ N (x|µ, s 2 ), and let its output mean and variance be ν and τ 2 . E.g., for the commonly used sigmoid unit
This integral can be evaluated exactly for the rectified linear unit f (x) = max(0, x). Let r = µ/s, then
The rectified linear unit is a special case of the maxout unit, for which techniques in can be used to compute its mean and variance.
With dropout training, each hidden unit also has an output variance. Sigmoid squared can be approximated by a translatedscaled version of the sigmoid:
Figure 2. MC dropout covariance matrices of the inputs of 50 random hidden units: left: at random initialization; right: trained to convergence. The covariance is not completely diagonal once trained to convergence. a,b can be found by matching the values and derivatives (a = 4 − 2 √ 2 and b = − log( √ 2 − 1)).
section: Training with backpropagation
The resulting neural network can be trained by backpropagation with two sets of partial derivatives. In normal backpropagation, one only needs to keep ∂L ∂µi for each hidden unit i with input µ i . For fast dropout training, we need ∂L ∂s 2 i as well for input variance s 2 i . Where
j w 2 ij and ν j and τ j are the output mean and variance of the previous layer. In practice, the method still works well if we ignore the output variance τ , so the input variance to the next layer is generated by dropout alone.
section: Relation to Bayesian model selection
Once we make the Gaussian approximation, there is an alternative interpretation of where the variance comes from. In the dropout framework, the variance comes from the dropout variable z. Under the alternative interpretation where w is a random variable, we can view dropout training as maximizing a lower bound on the Bayesian marginal likelihood among a class of models M µ indexed by µ ∈ R m . Concretely, let µ i = pw i , then the dropout objective
where Here the variance of v is tied to its magnitude, so a larger weight is only beneficial when it is robust to noise. While α can be determined by the dropout process, we are also free to choose α and we find empirically that using a slightly larger α than that determined by dropout often performs slightly better.
section: Experiments
section: Evaluating the assumptions and speed
For logistic regression (LR), shows that the quality of the gradient approximation using Gaussian samples is comparable to the difference between different MC dropout runs with 200 samples. shows that, under identical settings, the Gaussian approximation is much faster than MC dropout, and has a very similar validation error profile. Both Gaussian dropout training and real dropout training reduce validation error rate by about 30% over plain LR when trained to convergence, without ever overfitting.
section: Experiments on document classification
We show the performance of fast dropout LR on several sentiment and topic document classification tasks, both accuracy and time taken, in the top half of table 1. Sampling from the Gaussian is generally around 10 times faster than MC dropout and performs comparably to NBSVM in (, which is a method specifically engineered for document classification. Further speedup is achieved by directly optimizing the objective in and that is only 30% slower than plain logistic regression. While each iteration of fast dropout is still slower than LR, fast dropout sometimes reaches a better validation performance in less time as seen in. Note that for the MPQA dataset where the average number of non-zero dimensions ism ≈ 4, the Gaussian assumption is unjustifiable, but the derived method works empirically anyways. We compare to other papers in the bottom half  of the table 1, using either a test/train split or Nfold cross validation, depending on what is the most standard for the dataset. With the right regularization parameters and bigram features, our plain LR baseline is itself quite strong relative to previous work.
section: Experiments on MNIST
Experimental results on MNIST using 2-hidden-layer neural networks are shown in table 2 and the validation error curves with a slight smaller net are shown in. Here is a case where the data is fairly redundant so that dropping out input features does not make the problem much harder and MC dropout on minibatches converges fairly quickly. We replicate the original experiment using the exact settings described in () with a 20% dropout of the inputs, an exponentially decaying learning rate, a momentum schedule, and minibatch stochastic gradient descent. Under the learning schedule in the original experiment, no improvement resulted from doing fast dropout in the minibatch setting. In fact, each minibatch of fast dropout takes 1.5 times as much time as real dropout with 1 sample. However, the fast dropout objective is suitable for standard optimization technology, and we were able to train faster using L-BFGS where it converged in less than 100 epochs as opposed to over 500 epochs (see). 160 errors is the previous best result without pre-training or weightsharing or enhancement of the training data. Plain LR Gaussian approx. MC dropout. Validation errors vs. time spent in training (left), and number of iterations (right): trained using batch gradient descent on the 20-newsgroup subtask alt.atheism vs. religion.misc. 100 samples are used for both MC and Gaussian dropout. For MC dropout, zi is sampled only for non-zero xi.. Validation errors vs. epochs: we used the exact SGD training schedule described in () and a 784-800-800-10 2-hiden-layer neural network. This training schedule is presumably tuned for real dropout. fast dropout performs similarly to real dropout but with less variance. fast dropout batch: use batch L-BFGS and fast dropout, with validation error evaluated every 10 epochs.
section: Methods\ Datasets
simplicity. compares several test time methods on neural networks trained for MNIST and CIFAR using real dropout. Multiple real dropout samples and fast dropout provide a small but noticeable improvement overweight scaling.
section: Other experiments
The normal equations show the contrast between additive and multiplicative L 2 regularization. For linear regression, L 2 regularization outperformed dropout on 10 datasets from UCI that we tried. 1 Results on 5 of them are shown in table 4.
Classification results using neural networks on small UCI datasets are shown in table 5 where fast dropout does better than plain neural networks inmost cases.
section: Conclusions
We presented away of getting the benefits of dropout training without actually sampling, thereby speeding up the process by an order of magnitude. For high dimensional datasets (over a few hundred), each iteration of fast dropout is less than 2 times slower than normal training. We provided a deterministic and easy-to-compute objective function approximately equivalent to that of real dropout training. One can optimize this objective using standard optimization. Different test time methods on networks trained with real dropout: A 784-800-800-10 neural network is trained with real dropout on MNIST (3072-1000-1000-10 for CIFAR-10) and tested using: Full: use all weights without scaling; Scale: w ← pw; D(n): taken real dropout samples; FD: fast dropout.   methods, whereas standard methods are of limited use in real dropout because we only have a noisy measurement of the gradient. Furthermore, since fast dropout is not losing any information in individual training cases from sampling, it is capable of doing more work in each iteration, often reaching the same validation set performance in a shorter time and in less iterations.
section: Dataset
