section: title
Semantic Compositionality through Recursive Matrix-Vector Spaces
section: abstract
Single-word vector space models have been very successful at learning lexical information. However, they cannot capture the com-positional meaning of longer phrases, preventing them from a deeper understanding of language. We introduce a recursive neural network (RNN) model that learns compositional vector representations for phrases and sentences of arbitrary syntactic type and length. Our model assigns a vector and a matrix to every node in a parse tree: the vector captures the inherent meaning of the constituent, while the matrix captures how it changes the meaning of neighboring words or phrases. This matrix-vector RNN can learn the meaning of operators in propositional logic and natural language. The model obtains state of the art performance on three different experiments: predicting fine-grained sentiment distributions of adverb-adjective pairs; classifying sentiment labels of movie reviews and classifying semantic relationships such as cause-effect or topic-message between nouns using the syntactic path between them.
section: Introduction
Semantic word vector spaces are at the core of many useful natural language applications such as search query expansions (), fact extraction for information retrieval) and automatic annotation of text with disambiguated Wikipedia links), among many others (. In these models the meaning of a word is encoded as a vector computed from co-occurrence statistics of a word and its neighboring words. Such vectors have been shown to correlate well with human judgments of word similarity (. Despite their success, single word vector models are severely limited since they do not capture compositionality, the important quality of natural language that allows speakers to determine the meaning of a longer expression based on the meanings of its words and the rules used to combine them. This prevents them from gaining a deeper understanding of the semantics of longer phrases or sentences. Recently, there has been much progress in capturing compositionality in vector spaces, e.g.,) (see related work). We extend these approaches with a more general and powerful model of semantic composition.
We present a novel recursive neural network model for semantic compositionality. In our context, compositionality is the ability to learn compositional vector representations for various types of phrases and sentences of arbitrary length. shows an illustration of the model in which each constituent (a word or longer phrase) has a matrix-vector (MV) representation. The vector captures the meaning of that constituent. The matrix captures how it modifies the meaning of the other word that it combines with. A representation fora longer phrase is computed bottom-up by recursively combining the words according to the syntactic structure of a parse tree. Since the model uses the MV representation with a neural network as the final merging function, we call our model a matrix-vector recursive neural network (MV-RNN).
We show that the ability to capture semantic compositionality in a syntactically plausible way translates into state of the art performance on various tasks. The first experiment demonstrates that our model can learn fine-grained semantic compositionality. The task is to predict a sentiment distribution over movie reviews of adverb-adjective pairs such as unbelievably sad or really awesome. The MV-RNN is the only model that is able to properly negate sentiment when adjectives are combined with not. The MV-RNN outperforms previous state of the art models on full sentence sentiment prediction of movie reviews. The last experiment shows that the MV-RNN can also be used to find relationships between words using the learned phrase vectors. The relationship between words is recursively constructed and composed by words of arbitrary type in the variable length syntactic path between them. On the associated task of classifying relationships between nouns in arbitrary positions of a sentence the model outperforms all previous approaches on the. It outperforms all but one of the previous approaches without using any hand-designed semantic resources such as WordNet or FrameNet. By adding WordNet hypernyms, POS and NER tags our model outperforms the state of the art that uses significantly more resources. The code for our model is available at www.socher.org.
section: MV-RNN: A Recursive Matrix-Vector Model
The dominant approach for building representations of multi-word units from single word vector representations has been to form a linear combination of the single word representations, such as a sum or weighted average. This happens in information retrieval and in various text similarity functions based on lexical similarity. These approaches can work well when the meaning of a text is literally "the sum of its parts", but fails when words function as operators that modify the meaning of another word: the meaning of "extremely strong" cannot be captured as the sum of word representations for "extremely" and "strong."
The model of provided anew possibility for moving beyond a linear combination, through use of a matrix W that multiplied the word vectors (a, b), and a nonlinearity function g (such as a sigmoid or tanh). They compute the parent vector p that describes both words as
and apply this function recursively inside a binarized parse tree so that it can compute vectors for multiword sequences. Even though the nonlinearity allows to express a wider range of functions, it is almost certainly too much to expect a single fixed W matrix to be able to capture the meaning combination effects of all natural language operators. After all, inside the function g, we have the same linear transformation for all possible pairs of word vectors. Recent work has started to capture the behavior of natural language operators inside semantic vector spaces by modeling them as matrices, which would allow a matrix for "extremely" to appropriately modify vectors for "smelly" or "strong". These approaches are along the right lines but so far have been restricted to capture linear functions of pairs of words whereas we would like nonlinear functions to compute compositional meaning representations for multi-word phrases or full sentences.
The MV-RNN combines the strengths of both of these ideas by (i) assigning a vector and a matrix to every word and (ii) learning an input-specific, nonlinear, compositional function for computing vector and matrix representations for multi-word sequences of any syntactic type. Assigning vector-matrix representations to all words instead of only to words of one part of speech category allows for greater flexibility which benefits performance. If a word lacks operator semantics, its matrix can bean identity matrix. However, if a word acts mainly as an operator, such as "extremely", its vector can become close to zero, while its matrix gains a clear operator meaning, here magnifying the meaning of the modified word in both positive and negative directions.
In this section we describe the initial word representations, the details of combining two words as well as the multi-word extensions. This is followed by an explanation of our training procedure.
section: Matrix-Vector Neural Word Representation
We represent a word as both a continuous vector and a matrix of parameters. We initialize all word vectors x ∈ Rn with pre-trained 50-dimensional word vectors from the unsupervised model of. Using Wikipedia text, their model learns word vectors by predicting how likely it is for each word to occur in its context. Similar to other local co-occurrence based vector space models, the resulting word vectors capture syntactic and semantic information. Every word is also associated with a matrix X. In all experiments, we initialize matrices as X = I + , i.e., the identity plus a small amount of Gaussian noise. If the vectors have dimensionality n, then each word's matrix has dimensionality X ∈ R n×n . While the initialization is random, the vectors and matrices will subsequently be modified to enable a sequence of words to compose a vector that can predict a distribution over semantic labels. Henceforth, we represent any phrase or sentence of length m as an ordered list of vectormatrix pairs ((a, A), . . . , (m, M )), where each pair is retrieved based on the word at that position.
section: Composition Models for Two Words
We first review composition functions for two words. In order to compute a parent vector p from two consecutive words and their respective vectors a and b, give as their most general function: p = f (a, b, R, K),where R is the a-priori known syntactic relation and K is background knowledge.
There are many possible functions f . For our models, there is a constraint on p which is that it has the same dimensionality as each of the input vectors. This way, we can compare p easily with its children and p can be the input to a composition with another word. The latter is a requirement that will become clear in the next section. This excludes tensor products which were outperformed by simpler weighted addition and multiplication methods in).
We will explore methods that do not require any manually designed semantic resources as background knowledge K. No explicit knowledge about the type of relation R is used. Instead we want the model to capture this implicitly via the learned matrices. We propose the following combination function which is input dependent:
(2) where A, B are matrices for single words, the global W ∈ R n×2n is a matrix that maps both transformed words back into the same n-dimensional space. The element-wise function g could be simply the identity function but we use instead a nonlinearity such as the sigmoid or hyperbolic tangent tanh. Such a nonlinearity will allow us to approximate a wider range of functions beyond purely linear functions. We can also add a bias term before applying g but omit this for clarity. Rewriting the two transformed vectors as one vector z, we get p = g(W z) which is a single layer neural network. In this model, the word matrices can capture compositional effects specific to each word, whereas W captures a general composition function.
This function builds upon and generalizes several recent models in the literature. The most related work is that of) who introduced and explored the composition function p = Ba + Ab for word pairs. This model is a special case of Eq. 2 when we set W = [II] (i.e. two concatenated identity matrices) and g(x) = x (the identity function). computed the parent vector of adjective-noun pairs by p = Ab, where A is an adjective matrix and b is a vector fora noun. This cannot capture nouns modifying other nouns, e.g., disk drive. This model too is a special case of the above model with B = 0 n×n . Lastly, the models of () as described above are also special cases with both A and B set to the identity matrix. We will compare to these special cases in our experiments.
section: … very good movie … (a , A) (b , B) (c , C)
Matrix-Vector Recursive Neural Network
section: Recursive Compositions of Multiple Words and Phrases
This section describes how we extend a word-pair matrix-vector-based compositional model to learn vectors and matrices for longer sequences of words.
The main idea is to apply the same function f to pairs of constituents in a parse tree. For this to work, we need to take as input a binary parse tree of a phrase or sentence and also compute matrices at each nonterminal parent node. The function f can be readily used for phrase vectors since it is recursively compatible (p has the same dimensionality as its children). For computing nonterminal phrase matrices, we define the function
where W M ∈ R n×2n , so P ∈ R n×n just like each input matrix. After two words form a constituent in the parse tree, this constituent can now be merged with another one by applying the same functions f and f M . For instance, to compute the vectors and matrices depicted in, we first merge words a and band their matrices:
The resulting vector-matrix pair (p 1 , P 1 ) can now be used to compute the full phrase when combining it with word c and computing p 2 = f (Cp 1 , P 1 c), P 2 = f M (P 1 , C). The model computes vectors and matrices in a bottom-up fashion, applying the functions f, f M to its own previous output (i.e. recursively) until it reaches the top node of the tree which represents the entire sentence.
For experiments with longer sequences we will compare to standard RNNs and the special case of the MV-RNN that computes the parent by p = Ab + Ba, which we name the linear Matrix-Vector Recursion model (linear MVR). Previously, this model had not been trained for multi-word sequences. Sec. 6 talks about alternatives for compositionality.
section: Objective Functions for Training
One of the advantages of RNN-based models is that each node of a tree has associated with it a distributed vector representation (the parent vector p) which can also be seen as features describing that phrase. We train these representations by adding on top of each parent node a simple softmax classifier to predict a class distribution over, e.g., sentiment or relationship classes:
For the applications below (excluding logic), the corresponding error function E(s, t, θ) that we minimize fora sentence sand its tree t is the sum of cross-entropy errors at all nodes.
The only other methods that use this type of objective function are), who also combine it with either a score or reconstruction error. Hence, for comparisons to other related work, we need to merge variations of computing the parent vector p with this classifier. The main difference is that the MV-RNN has more flexibility since it has an input specific recursive function f A,B to compute each parent. In the following applications, we will use the softmax classifier to predict both sentiment distributions and noun-noun relationships.
section: Learning
be our model parameters and λ a vector with regularization hyperparameters for all model parameters. Land L M are the sets of all word vectors and word matrices. The gradient of the overall objective function J becomes:
To compute this gradient, we first compute all tree nodes (p i , P i ) from the bottom-up and then take derivatives of the softmax classifiers at each node in the tree from the top down. Derivatives are computed efficiently via backpropagation through structure (. Even though the objective is not convex, we found that L-BFGS run over the complete training data (batch mode) minimizes the objective well in practice and convergence is smooth. For more information see).
section: Low-Rank Matrix Approximations
If every word is represented by an n-dimensional vector and additionally by an n × n matrix, the dimensionality of the whole model may become too large with commonly used vector sizes of n = 100. In order to reduce the number of parameters, we represent word matrices by the following low-rank plus diagonal approximation:
where U ∈ R n×r , V ∈ R r×n , a ∈ Rn and we set the rank for all experiments tor = 3.
section: Discussion: Evaluation and Generality
Evaluation of compositional vector spaces is a complex task. Most related work compares similarity judgments of unsupervised models to those of human judgments and aims at high correlation. These evaluations can give important insights. However, even with good correlation the question remains how these models would perform on downstream NLP tasks such as sentiment detection. We experimented with unsupervised learning of general vector-matrix representations by having the MV-RNN predict words in their correct context. Initializing the models with these general representations, did not improve the performance on the tasks we consider. For sentiment analysis, this is not surprising since antonyms often get similar vectors during unsupervised learning from co-occurrences due to high similarity of local syntactic contexts. In our experiments, the high prediction performance came from supervised learning of meaning representations using labeled data. While these representations are task-specific, they could be used across tasks in a multi-task learning setup. However, in order to fairly compare to related work, we use only the supervised data of each task. Before we describe our fullscale experiments, we analyze the model's expressive powers.
section: Model Analysis
This section analyzes the model with two proof-ofconcept studies. First, we examine its ability to learn operator semantics for adverb-adjective pairs. If a model cannot correctly capture how an adverb operates on the meaning of adjectives, then there's little chance it can learn operators for more complex relationships. The second study analyzes whether the MV-RNN can learn simple boolean operators of propositional logic such as conjunctives or negation from truth values. Again, if a model did not have this ability, then there's little chance it could learn these frequently occurring phenomena from the noisy language of real texts such as movie reviews.
section: Predicting Sentiment Distributions of Adverb-Adjective Pairs
The first study considers the prediction of finegrained sentiment distributions of adverb-adjective pairs and analyzes different possibilities for computing the parent vector p. The results show that the MV-RNN operators are powerful enough to capture the operational meanings of various types of adverbs. For example, very is an intensifier, pretty is an attenuator, and not can negate or strongly attenuate the positivity of an adjective. For instance not great is still pretty good and not terrible; see Potts (2010) for details. We use a publicly available IMDB dataset of extracted adverb-adjective pairs from movie reviews. The dataset provides the distribution over star ratings: Each consecutive word pair appears a certain number of times in reviews that have also associated with them an overall rating of the movie. After normalizing by the total number of occurrences, one gets a multinomial distribution over ratings. Only word pairs that appear at least 50 times are kept. Of the remaining pairs, we use 4211 randomly sampled ones for training and a separate set of 1804 for testing. We never give the algorithm sentiment distributions for single words, and, while single words overlap between training and testing, the test set consists of never before seen word pairs.
The softmax classifier is trained to minimize the cross entropy error. Hence, an evaluation in terms of KL-divergence is the most reasonable choice. It is  defined as KL(g||p) = i g i log(g i /p i ), where g is the gold distribution and p is the predicted one.
We compare to several baselines and ablations of the MV-RNN model. An (adverb,adjective) pair is described by its vectors (a, b) and matrices (A, B). We cross-validated all models over regularization parameters for word vectors, the softmax classifier, the RNN parameter W and the word operators (10 −4 , 10 −3 ) and word vector sizes. All models performed best at vector sizes of below 12. Hence, it is the model's power and not the number of parameters that determines the performance. The table in shows the average KL-divergence on the test set. It shows that the idea of matrix-vector representations for all words and having a nonlinearity are both important. The MV-RNN which combines these two ideas is best able to learn the various compositional effects. The main difference in KL divergence comes from the few negation cases in the test set. shows examples of predicted distributions. Many of the predictions are accurate and similar between the top models. However, only the MV-RNN has enough expressive power to allow negation to completely shift the sentiment with respect to an adjective. A negated adjective carrying negative sentiment becomes slightly positive, whereas not awesome is correctly attenuated. All three top models correctly capture the U-shape of unbelievably sad. This pair peaks at both the negative and positive spectrum because it is ambiguous. When referring to the performance of actors, it is very negative, but, when talking about the plot, many people enjoy sad and thought-provoking movies. The p = Ab model does not perform well because it cannot model the fact that for an adjective like "sad," the operator of "unbelievably" behaves differently.: Training trees for the MV-RNN to learn propositional operators. The model learns vectors and operators for ∧ (and) and ¬ (negation). The model outputs the exact representations of false and true respectively at the top node. Hence, the operators can be combined recursively an arbitrary number of times for more complex logical functions.
section: Logic-and Vector-based Compositionality
Another natural question is whether the MV-RNN can, in general, capture some of the simple boolean logic that is sometimes found in language. In other words, can it learn some of the propositional logic operators such as and, or, not in terms of vectors and matrices from a few examples. Answering this question can also be seen as a first step towards bridging the gap between logic-based, formal semantics and vector space models.
The logic-based view of language accounts nicely for compositionality by directly mapping syntactic constituents to lambda calculus expressions. At the word level, the focus is on function words, and nouns and adjectives are often defined only in terms of the sets of entities they denote in the world. Most words are treated as atomic symbols with no relation to each other. There have been many attempts at automatically parsing natural language to a logical form using recursive compositional rules.
Conversely, vector space models have the attractive property that they can automatically extract knowledge from large corpora without supervision. Unlike logic-based approaches, these models allow us to make fine-grained statements about the semantic similarity of words which correlate well with human judgments (. Logic-based approaches are often seen as orthogonal to distributional vector-based approaches. However, One open question is whether vector-based models can learn some of the simple logic encountered in language such as negation or conjunctives. To this end, we illustrate in a simple example that our MV-RNN model and its learned word matrices (operators) have the ability to learn propositional logic operators such as ∧, ∨, ¬ (and, or, not). This is a necessary (though not sufficient) condition for the ability to pickup these phenomena in real datasets and tasks such as sentiment detection which we focus on in the subsequent sections.
Our setup is as follows. We train on 6 strictly right-branching trees as in. We consider the 1-dimensional case and fix the representation for true to (t = 1, T = 1) and false to (f = 0, F = 1). Fixing the operators to the 1 × 1 identity matrix 1 is essentially ignoring them. The objective is then to create a perfect reconstruction of (t, T ) or (f, F ) (depending on the formula), which we achieve by the least squares error between the top vector's representation and the corresponding truth value, e.g. for ¬f alse:
As our function g (see Eq. 2), we use a linear threshold unit: g(x) = max(min(x, 1), 0). Giving the derivatives computed for the objective function for the examples in to a standard L-BFGS optimizer quickly yields a training error of 0. Hence, the output of these 6 examples has exactly one of the truth representations, making it recursively compatible with further combinations of operators. Thus, we can combine these operators to construct any propositional logic function of any number of inputs (including xor). Hence, this MV-RNN is complete in terms of propositional logic.
section: Predicting Movie Review Ratings
In this section, we analyze the model's performance on full length sentences. We compare to previous state of the art methods on a standard benchmark dataset of movie reviews (Pang and). This dataset consists of 10,000 positive and negative single sentences describing movie sentiment. In this and the next experiment we use binarized trees from the Stanford Parser (. We use the exact same setup and parameters (regularization, word vector size, etc.) as the published code of.
section: Method
Acc. Tree-CRF ( 77.3 RAE ( 77.7 Linear MVR 77.1 MV-RNN 79.0 and negative (0) sentiment (S.) that of all methods only the MV-RNN predicted correctly (C: √ ) or could not classify as correct either (C: x). shows comparisons to the system of), a dependency tree based classification method that uses CRFs with hidden variables. The state of the art recursive autoencoder model of obtained 77.7% accuracy. Our new MV-RNN gives the highest performance, outperforming also the linear MVR (Sec. 2.2). shows several hard examples that only the MV-RNN was able to classify correctly. None of the methods correctly classified the last two examples which require more world knowledge.
section: Classification of Semantic Relationships
The previous task considered global classification of an entire phrase or sentence. In our last experiment we show that the MV-RNN can also learn how a syntactic context composes an aggregate meaning of the semantic relationships between words. In particular, the task is finding semantic relationships between pairs of nominals. For instance, in the sentence "My e1 has a pretty large e2 .", we want to predict that the kitchen and apartment are in a component-whole relationship. Predicting such  semantic relations is useful for information extraction and thesaurus construction applications. Many approaches use features for all words on the path between the two words of interest. We show that by building a single compositional semantics for the minimal constituent including both terms one can achieve a higher performance. This task requires the ability to deal with sequences of words of arbitrary type and length in between the two nouns in question. explains our method for classifying nominal relationships. We first find the path in the parse tree between the two words whose relation we want to classify. We then select the highest node of the path and classify the relationship using that node's vector as features. We apply the same type of MV-RNN model as in sentiment to the subtree spanned by the two words.
We use the dataset and evaluation framework of). There are 9 ordered relationships (with two directions) and an undirected other class, resulting in 19 classes. Among the relationships are: messagetopic, cause-effect, instrument-agency (etc. see for list). A pair is counted as correct if the order of the words in the relationship is correct. lists results for several competing methods together with the resources and features used by each method. We compare to the systems of the competition which are described in as well as the RNN and linear MVR. Most systems used a considerable amount of handdesigned semantic resources. In contrast to these methods, the MV-RNN only needs a parser for the tree structure and learns all semantics from unlabeled corpora and the training data. Only the SemEval training dataset is specific to this task, the re-  maining inputs and the training setup are the same as in previous sentiment experiments.
The best method on this dataset (Rink and Harabagiu, 2010) obtains 82.2% F1. In order to see whether our system can improve over this system, we added three features to the MV-RNN vector and trained another softmax classifier. The features and their performance increases were POS tags (+0.9); WordNet hypernyms (+1.3) and named entity tags (NER) of the two words (+0.6). Features were computed using the code of Ciaramita and Altun (2006). 3 With these features, the performance improved over the state of the art system. shows random correct classification examples.
section: Related work
Distributional approaches have become omnipresent for the recognition of semantic similarity between words and the treatment of compositionality has seen much progress in recent years. Hence, we cannot do justice to the large amount of literature. Commonly, single words are represented as vectors of distributional characteristics -e.g., their frequencies in specific syntactic relations or their co-occurrences with given context words (. These representations have proven very effective in sense discrimination and disambiguation, automatic thesaurus extraction) and selectional preferences.
There are several sophisticated ideas for compositionality in vector spaces. present an overview of the most important compositional models, from simple vector addition and component-wise multiplication to tensor products, and convolution. They measured the similarity between word pairs such as compound nouns or verb-object pairs and compared these with human similarity judgments. Simple vector averaging or multiplication performed best, hence our focus on related baselines above.
Other important models are tensor products, quantum logic, holographic reduced representations and the Compositional Matrix Space model. RNNs are related to autoencoder models such as the recursive autoassociative memory (RAAM) or recurrent neural networks. and discussed related models such as recursive autoencoders for text understanding.
Our model builds upon and generalizes the models of) (see Sec. 2.2). We compare to them in our experiments. introduce a sentiment analysis model that describes words as matrices and composition as matrix multiplication. Since matrix multiplication is associative, this cannot capture different scopes of negation or syntactic differences. Their model, is a special case of our encoding model (when you ignore vectors, fix the tree to be strictly branching in one direction and use as the matrix composition function P = AB). Since our classifiers are trained on the vectors, we cannot compare to this approach directly. Grefenstette and Sadrzadeh (2011) learn matrices for verbs in a categorical model. The trained matrices improve correlation with human judgments on the task of identifying relatedness of subjectverb-object triplets.
section: Conclusion
We introduced anew model towards a complete treatment of compositionality in word vector spaces. Our model builds on a syntactically plausible parse tree and can handle compositional phenomena. The main novelty of our model is the combination of matrix-vector representations with a recursive neural network. It can learn both the meaning vectors of a word and how that word modifies its neighbors (via its matrix). The MV-RNN combines attractive theoretical properties with good performance on large, noisy datasets. It generalizes several models in the literature, can learn propositional logic, accurately predicts sentiment and can be used to classify semantic relationships between nouns in a sentence.
