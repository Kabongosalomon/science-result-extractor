section: title
Neural Semantic Parsing by Character-based Translation: Experiments with Abstract Meaning Representations
section: abstract
We evaluate the character-level translation method for neural semantic parsing on a large corpus of sentences annotated with Abstract Meaning Representations (AMRs). Using a sequence-to-sequence model, and some trivial preprocessing and postprocessing of AMRs, we obtain a baseline accuracy of 53.1 (F-score on AMR-triples). We examine five different approaches to improve this baseline result: (i) reordering AMR branches to match the word order of the input sentence increases performance to 58.3; (ii) adding part-of-speech tags (automatically produced) to the input shows improvement as well (57.2); (iii) So does the introduction of super characters (conflating frequent sequences of characters to a single character), reaching 57.4; (iv) optimizing the training process by using pre-training and averaging a set of models increases performance to 58.7; (v) adding silver-standard training data obtained by an off-the-shelf parser yields the biggest improvement , resulting in an F-score of 64.0. Combining all five techniques leads to an F-score of 71.0 on holdout data, which is state-of-the-art in AMR parsing. This is remarkable because of the relative simplicity of the approach.
section: Introduction
Various approaches to open-domain semantic parsing have been proposed in the last years. What we now could refer to as "traditional" approaches are semantic parsers that use supervised learning to create a syntactic analysis on which the meaning representations are constructed, usually in a compositional way. Research in this area comprises,,,,,,, and many others. Efforts to create datasets of sentences paired with meaning representations have stimulated research in semantic parsing (, especially those using the formalism of Abstract Meaning Representation (AMR), for which also shared tasks have been organized. In this article, therefore, we concentrate on semantic parsing of AMRs, because large gold-standard datasets are available and various different approaches can be compared.
In contrast to the traditional approaches mentioned above, there have been interesting attempts recently to view semantic parsing as a translation task, mapping English expressions to logical forms under supervision of some deep learning method. used sequenceto-sequence (seq2seq) and sequence-to-tree (seq2tree) neural translation models to produce logical forms from sentences for four different datasets (but not AMRs). used a similar method to produce AMRs in the context of the previously mentioned shared task, but the performance of their neural parser was still far below the state-of-the-art. Despite this, their method inspired other researchers to adopt this seq2seq approach (). But, even though they got substantial improvements over, their systems still did not come close to state-of-the-art. The neural approach of did reach state-of-the-art performance, but they used five bi-LSTM networks instead of a single seq2seq model.
What all these attempts have in common, and why they are fascinating, is that they completely avoid complex models of the syntactic and semantic parsing process and therefore do not rely on heavily engineered features. However, except for, they also only use word-level input. This is interesting, because obtained a substantial improvement for their character-level model over their word-level model. Character-embeddings, since they were introduced by, have also shown improvements in a number of areas, such as POS-tagging), text classification (), and, most importantly, Neural Machine Translation (.
The aim of this article is to find out how far we can push character-level neural semantic parsing: can we reach accuracy scores comparable with traditional approaches to semantic parsing? More specifically, our objectives are (1) try to reproduce the results of; improve on their results by employing several novel techniques; and (3) investigate whether injecting linguistic knowledge can improve neural semantic parsing.
We make three main contributions. First, we introduce novel techniques to improve neural AMR parsing. Second, we show that linguistic knowledge can still contribute to neural semantic parsing. Third, we show that adding silver standard to the training data makes a considerable (positive) difference in terms of performance. Our final model reaches an F-score of 71.0, which is the current state-of-the-art in AMR parsing.
section: Method and Data
We first give a bit of background on AMRs. Then we outline the basic ideas of the character-based translation model with English sentences as input and AMRs as output. We then establish a baseline system with the aim to improve it in the next section.
section: Abstract Meaning Representations
In our experiments utilizing neural semantic parsing we will focus on parsing Abstract Meaning Representations (AMRs). AMRs were introduced by and are acyclic, directed graphs that represent the meaning of a sentence. There are, in fact, three ways to display an AMR: as a graph, as a set of triples, or as a tree. An example of an AMR is shown in, here displayed as a tree, the format that is used in the annotated corpora. The corresponding triple representation is shown in.
(a / affect-01 :ARG0 (w / wave-04 :ARG1 (h2 / heat) :location (c / country :wiki "France" :name (n / name :op1 "France"))) :ARG1 (p / person :ARG0-of (s / strike-02 :mod (h / hunger-01 :ARG0 p))))
Figure 1: AMR representing the meaning of Hunger strikers were affected by France's heatwave.
An AMR consists of concepts that are linked to variable names with a slash. In the example above we have that a is an instance of the concept affect-01, and p is an instance of the concept person (note that the names of the variables are not important). Concepts can be related to each other by using two-place predicates, which are indicated by a colon. So, the first :ARG0 is an ordered relation between a and w. Inverse relations are denoted by the suffix -of. Note that, if one concept relates to more than one other concept (for instance, in the example above, the node a is related tow via :ARG0, and top via :ARG1), the order of these relations within the AMR is not important. AMRs also allow fora re-occurrence of variables: the concept person with variable p stands in a relation with affect-01 as well as with hunger-01. The brackets are important, because they signal which relations belong to which concepts (the spacing used in is optional and is only used to increase readability). Some of the concepts have a number as suffix that indicate a specific word sense. AMRs also include proper name reference resolution by including a link to a wikipedia entry (wikification).
For evaluation purposes, AMRs are converted into triples. The triples of the AMR in are shown in.
The accuracy of an AMR parser is computed by precision and recall on matching triples between gold standard AMRs and system-produced AMRs, using the SMATCH system.
For the evaluation of our experiments we use the sentences annotated with AMRs from LDC release LDC2016E25 1 , consisting of 36,521 training AMRs, 1,368 development AMRs and 1,371 test AMRs.
This release also includes the PropBank frameset and comes with pre-aligned AMRs and sentences. In all results shown in this article, the models are trained on the training data. As development and test data we use the designated dev and test set from LDC2016E25, which are the exact same sets that are used in LDC2015E89. We remove HTML-tags from the input sentences, but URLs are kept in.
section: The Basic Translation Model
To create our sequence-to-sequence translation model, we use the OpenNMT system (. In contrast to and, who use word-level input, we use character-level input . We train a model with bidirectional encoding and general attention (). Since training a full model takes two to three days on a GPU, we perform a heuristic parameter search instead of an exhaustive one. We started outwith a default model and changed only one parameter value in separate experiments. If we improved over the default, the setting was kept and combined with other parameter settings that improved performance. All models were only tested on the development set. Ultimately, we arrived at the settings shown in. All our described models in this paper are trained with these settings. Training is stopped 3 epochs after there is no improve-ment in validation perplexity on the development set anymore. The best performing model on the development set is then used to decode the test set., we do not want our model to learn the arbitrary characters that are used to represent variables. The characters itself do not carry any semantic information and are only necessary to indicate co-referring nodes. Therefore we remove all variables from the AMRs and simply duplicate co-referring nodes from the input. An example of such a preprocessed AMR is shown in. Note that this means that we lose information, since the variables cannot be put back perfectly. We describe an approach to restore the co-referring nodes in the output in section 2.3.3. All wikification relations present in AMRs in the training set are also removed and restored in a post-processing step. Newlines present in an AMR are replaced by spaces, and multiple spaces are squeezed into single ones (so the input AMR is represented on a single line). :ARG1-of (use-01 :ARG2 (make-01 :ARG1 (heroin) :ARG2 (opium))))
Figure 2: Example of the original AMR (left) and the variable-free AMR (right) displaying the meaning of Opium is the raw material used to make heroin.
section: Postprocessing and Restoring Information
The output of the seq2seq model is, of course, an AMR without variables, without wiki-links, and without co-occurrent variables. Furthermore, because of the character-based seq2seq model, it could well be that there are brackets in the output that do not match, or that some nodes representing concepts are incomplete. This, obviously, needs to be fixed. First, the variables in the AMRs are restored by assigning a unique variable to each concept. We also try to fix invalidly produced AMRs by applying a few heuristics, such as inserting parentheses and quotes, or by removing unfinished nodes. This is done by using the restoring script from. Then, we apply three methods to increase the quality of the AMRs. They are described below.
section: Pruning
A problem with many deep learning approaches is the fact that the decoder does not keep track of what it has already produced. As a consequence, we sometimes end up with duplicated, redundant material in our generated AMRs. This hurts precision. We propose four different methods to remove this redundant material. This is done on node level, where nodes are defined as relation-concept pairs without children, e.g. :mod (raw) and :domain (opium). The statistics of applying these four methods on our baseline model (dev set) are shown in. Note that all these processes are trade-offs: usually duplicates are correctly recognized as redundant and can be removed, but sometimes we erroneously remove actual re-occurrent nodes.
The first method simply removes all re-occurrent nodes and is already quite effective: F-score increases by 0.6. The second method is more careful and only removes duplicate nodes if they have the same parent. This helps, but only by a small margin. The third method does not consider parent nodes, but removes nodes if they occur more than twice in the full AMR. This method also increases the F-score, but does not outperform the first method yet. The fourth method is a combination of the second and third method. All re-occurrent nodes with the same parent are removed, but also nodes occurring more than twice are removed. This results in the best F-score, an increase of 0.7 over the baseline. Two example AMRs whose branches are pruned using the fourth method are shown in. Figure 3: Example of pruned branches for the produced AMRs of Opium is the raw material used to make heroin. In the left AMR, the second occurrence of :mod (raw) is already removed, because both branches are children of material. However, in the right AMR, none of the :mod (raw) branches share the same parent, so only the third occurrence is removed.
section: Wikification
Since we removed wikification relations in preprocessing, our model will never output such a link. We restore wiki links in the output AMR by using an off-the-shelf system (), following the method presented by. They look at the :name relations in an AMR and try to find this name on Wikipedia. If it has a page, the corresponding link gets added; otherwise the AMR remains unaltered.
section: Restoring co-referring nodes
Our system also tries to restore co-referring nodes. If we output a duplicate node (a node already produced for this AMR), it replaces the node by the variable name of the node encountered first. This can only happen once per unique node, since the third instance of such anode is already removed in the pruning phase. An example of how the co-referring nodes are restored is shown in.
section: Baseline Results
Our first objective was to reproduce the results obtained by. We did so, arriving at an F-score of 53.1 (see). Compared to the F-score of 43.0 by, our score is significantly higher. This is probably due to the higher amount of training data and the fact that they used Tensorflow instead of OpenNMT. We also reproduced their results by using the exact same data, software and parameter settings as they did, obtaining an F1-score of 42.3. 5 As is shown in, concept pruning, restoring co-reference variables, and wikification all increase the F-score by about a percentage point each. This small gain of performance is what one could expect as each single operation has only a small impact on the overall contents of an AMR.
5. We did not possess their Wikification and coreference restoring scripts, so differences might be attributed to that.
section: Improving the Basic Translation Model
In the previous section we outlined our basic method of producing AMRs using a seq2seq model based on characters. In this section, we look at five different techniques to move beyond the F-score that we obtain with our basic method, that we will consider in this section as baseline. Some of the techniques were already (briefly) introduced in van Noord and Bos (2017).
section: AMR Re-ordering
Although AMRs are unordered by definition, in our textual representation of the AMRs there is an order of the branches. However, these branches do not necessarily follow the word order in the corresponding English sentence. It has been shown that for (statistical) machine translation reordering improves translation quality (). We use the provided alignments to permute the AMR in such away that it best matches the word order. We do this both on sub-tree level and on individual node level. The best matching AMR is defined as the AMR in which the order of the nodes (when traversing over the AMR depth-first) is the closest to the order of the words in the English sentence, following the alignments. An example of an AMR with a branch order best matching the input sentence is shown in. Figure 5: Example of a variable-free AMR before (left) and after re-ordering (right) for the sentence Opium is the raw material used to make heroin.
We are also able to use this approach to augment the training data, since each reordering of the AMR provides us with anew AMR-sentence pair. Due to the exponential increase, large AMRs often have thousands of possible orders. We performed a number of experiments to find out how we could best exploit this surplus of data. Ultimately, we found that it is most beneficial to "double" the training data by adding the best matching AMR to the existing data set.
section: Introducing Super Characters
We are not necessarily restricted to only using characters as input. For example, we can view the AMR relations (e.g. :ARG0, :mod) as atomic instead of a set of characters. This ensures that the characters for relations (e.g. m, o and d for :mod) do not influence the general character embeddings of the concepts, which might improve performance. This way, we create a hybrid model that is a combination of word and character level input. An example of the AMR and sentence level input using super characters is shown in and.
We also tried various ways to explicitly encode the tree structure by using super characters. In our basic model, the parentheses '(' and ')' are simply characters. This means that the model cannot. Instead of ordering the AMR nodes reflected by the word order of sentence, we also tried two different experiments based on consistency. The first experiment simply ordered the nodes alphabetically, without any other influence. This decreased the result of our baseline model by 2.0. Our second experiment was focused on fixing irregularities: if two nodes occur in a different order than they usually do (based on the full training set), we simply switch them around. This method did not change the order as considerably as the alphabetical ordering, but the result of the baseline model still decreased by 1.0. Hence we discarded both reordering techniques.
section: AMR, chars:
( t hi n g + : q u an t + 1 + : p o la r it y + -) AMR, super chars: ( t hi n g + :quant + 1 + :polarity + -)  differentiate between a parenthesis that opens the full AMR and a parenthesis that opens, say, the fifth subtree of the AMR. One would expect it would help the model if it has this information explicitly encoded in the input. For example, in an experiment we replaced each parenthesis in the structure by a super character that also provides the subtree information (e.g., an opening parenthesis on the fifth level becomes *5*(, while a closing bracket on the third level becomes *3*).
However this resulted in an F-score lower than the baseline and we discarded the technique.
section: Adding Part-of-Speech Information
We might still be able to benefit from syntactic information, even though we use a character-level neural semantic parser. To show this, we parse the sentences with the POS-tagger of the C&C tools (), employing the Penn POS tagset. Each tag is represented as a single character and placed after the last character representation of the word that matches the tag (see). Put differently, we create anew super character for each unique tag and add this to the input sentence.
On the one hand, this will increase the size of the input. On the other hand, just a single character will add a lot of general, potentially useful, information. For example, proper nouns correlate with the :name relation, while adjectives correlate with the :mod relation.
section: Adding Silver Standard Data
A problem with neural parsing approaches is data sparsity, since a lot of manual effort is required to create gold standard data. tried to overcome this by extensive generalization of the training data, but did not get near state-of-the-art results. applied a similar method, but also used the GigaWord corpus to self-train their system. They use their own pre-trained parser to parse the previously unseen sentences and add those to the training data in a series of iterations. Ultimately, their system is trained on 20 million additional data AMR-sentence pairs and obtains an F-score of 62.1. Without this additional data, they obtain a score of 55.5, which is better than, but not close to state-of-the-art performance.
Our method of obtaining new training data mainly differs from in two ways: (i) we use two off-the-shelf parsers to create the training data instead of self-training; (ii) we employ a method to exclude lower-quality AMRs instead of using all available data. We therefore refer to this data as "silver standard" data, by which we mean something in between unchecked automatically produced data and gold standard data.
Instead of self-training our parser, we use the off-the-shelf AMR parsers CAMR () and JAMR () to create silver standard data for our system. Both are non-neural, syntax-based parsers. CAMR works by first generating a dependency tree for the English sentence, after which it uses a transition-based algorithm to create the AMR graph. JAMR is the first published AMR parser and does the parsing in two stages: first identifying the concepts by using a semi-Markov model, and then identifying the relations between these concepts by searching for the maximum spanning connected subgraph.
Both systems are trained on the LDC2015E86 AMR corpus, which contains 16,833 training instances. We parse 1,303,419 sentences from the Groningen Meaning Bank (), which mainly consists of newswire text. AMRs that are either invalid or include null-tag or null-edge (this is what the CAMR parser outputs when it is notable to find a suitable candidate parse) are removed.
We do not simply add the other AMRs to our data set. To ensure that the AMRs are at least of decent quality, we compare the produced AMRs with each other using SMATCH. If their pairwise score does not exceed 55.0, the AMRs are not considered for adding to our training set. This value was picked to filter out AMRs that would only hurt the training process, but to also still include a large variety of AMRs and sentences. Our final set contained 530,450 sentences, that have both a CAMR and JAMR parse.
We now have to determine which AMR to add to our silver data set. CAMR produces higher quality AMRs in general (64.0 vs 55.0 on the test set), but it might be beneficial to introduce some variety by also adding JAMR-parsed AMRs. We never add both CAMR and JAMR for the same sentence. We performed five experiments in which we added 100k silver AMRs, either containing 100%, 75%, 67%, 50% or 0% CAMR-parsed AMRs. The results of testing on the development set are shown in.: F-scores on the dev set for adding different ratios of CAMR and JAMR parsed AMRs to our initial data set. All scores are without postprocessing improvement methods.
# CAMR AMRs # JAMR AMRs F-score 100,000 0 65.8 75, 25,000 65.8 66, 33,333 65.7 50,000 50,000 65.3 0 100,000 61.4
As would be expected, we see that only adding CAMR scores considerably better than only adding JAMR. However, the scores for adding 67% and 75% CAMR are very similar to adding 100% CAMR. But, since this does not indicate that adding JAMR actually helps performance, we only add the CAMR-parsed AMRs in our silver data experiments. We randomly selected 20k, 50k, 75k, 100k and 500k instances for these experiments.
section: Optimizing training
Aside from the pre-and post-processing methods described, we can also optimize the training process itself. The first method we employ is pre-training on our full data set including silver AMRs, after which the model is fine-tuned on the gold data only. Both phases use the same parameter settings, as experiments with different learning rates resulted in lower performance. A similar procedure was used by and in general this is a method widely used in Neural Machine Translation.
The second method is averaging a set of models to decode the test set, instead of using a single model. This was first applied by as an alternative to the usual ensembling of models, which is known to give substantial improvements in Neural Machine Translation (). Ensembling, however, is very resource intensive, since the predictions of different models are averaged at decoding time. This as opposed to averaging, where the parameters of models are averaged to create a single model. This means that averaging, say, four models is four times faster than ensembling four models, while also using only a quarter of the memory the ensemble method uses. We tested with both ensembling and averaging and obtained similar results on the development set, thus opting to only use averaging in our experiments. shows the results of our improvement methods in isolation, meaning that only that individual method is added to our baseline model. Re-ordering has a clear positive effect, both for using the best re-ordering (+2.0) and adding that re-ordering to the existing data set (+5.2). Constructing super characters and adding POS-tags both lead to a similar increase in performance. Pre-training and subsequently fine-tuning also results in a substantial improvement, but creating an average model only has a slight positive effect. The biggest improvement comes from adding silver standard data to our training set, reaching a maximum of 65.8 on the dev set. However, there is a limit with regards to adding silver data, since adding 500k silver AMRs performed worse than adding 50k, 75k or 100k silver AMRs. Finding the optimal number of silver AMRs is difficult due to the long training times and is therefore left for future work. Since the previous experiments were all in isolation, we now test whether a combination of our methods still increases performance. The tested combinations are shown in. Even after adding the silver data, the addition of POS-tags and super characters still increased the performance, albeit by a smaller margin. Interestingly, the best result (71.0) was not obtained by combining all improvement methods, since re-ordering the AMRs does not show an increase anymore after adding POS-tags and super characters. The best model without using any silver data obtains an F-score of 64.0, which is considerably higher than the AMR-only score (55.5) of. shows the results of the most notable previous AMR parsing systems. Our best model outperforms all these previous parsers and reaches state-of-the-art results. However, we are also the first approach that uses the LDC2016E25 data set, which contains slightly more than double the number of gold standard training instances compared to the LDC2015E86 data set. 7 Therefore, we also trained the best performing model in on the LDC2015E86 data set, while still applying all our improvement methods. This model still obtains an F-score of 68.5, outperforming all previous AMR parsers, except for the parser of. presented away to evaluate system output in a more detailed way, by focussing on various aspects that are present in an AMR: the role labelling, word sense disambiguation, named entity recognition, wikification, detecting negation, and soon. These detailed results of our best system are shown in, in which the results of the other parsers are taken from. Unfortunately, Foland and Martin (2017) did not publish these specific scores. As the table shows, our system scores higher than the other parsers on five of the eight metrics other than Smatch. In general, our system is quite conservative, obtaining a higher precision than recall for each metric. Given the results in, one would think that detecting negation and reentrancy would be ways to get an improvement inaccuracy. Note that the other parsers score also relatively bad at these metrics. Compared to the other systems, our system scores worse on concepts, named entities, and wikification. A possible method to increase performance in the first two of those metrics 7. LDC2015E86 only contains 16,833 instances, as opposed to the 36,521 of LDC2016E25.
section: Results and Discussion
is to adopt an anonymization or generalization approach for named entities and concepts, similar to or.: Comparison with previous parsers using the evaluation script of. We also included precision and recall scores for our system.
CAMR JAMR-16 AMR-
section: Conclusion and Future Work
Applying re-ordering of AMR branches, introducing super characters, and adding POS-tags are techniques that substantially improve neural AMR parsing using a character-based seq2seq model. However, the biggest increase of performance is triggered by adding a large quantity of silver standard AMRs produced by existing (traditional) parsers. This is inline with the findings of, who used the Gigaword corpus to get extra training data, although their training method is different from ours. The obtained results are promising. Our best model, with an F-score of 71.0, outperformed any known previously published result on AMR parsing. This is remarkable, for traditional approaches are often based on extensive, manually crafted lexicons using linguistic knowledge. It should be noted, of course, that we use some linguistic knowledge in the form of POS-tags in our best models, and that we employ existing parsers trained on extensive linguistics annotations. In fact, one could consider the use of silver standard AMR data as a disadvantage, as there is still a need of an existing high-quality AMR parser to get the silver data in the first place. In our approach we rely even on two different off-the-shelf parsers. It would therefore be interesting to explore other opportunities, such as self-learning, as proposed by.
We have the feeling that there are still a lot of techniques that one could try to increase the performance of neural AMR parsing. From a more esthetical perspective, it would be nice if one could eliminate the AMR repair strategies that are used to resolve unbalanced brackets. An interesting candidate that could master this problem would be the seq2tree model presented by. Similarly, a more principled approach to deal with co-occurring variables would be desirable.
Another possible next step in semantic parsing is to change the target meaning representation. AMRs are unscoped meaning representations, and have no quantifiers. It would be challenging to transfer the techniques of neural semantic parsing to scoped meaning representations, such as those used in the Groningen Meaning Bank () or the Parallel Meaning Bank ().
